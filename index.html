<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Baghdatis Academy: Pixel Pathway</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #060a0f;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      min-height: 100dvh;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #wrap {
      position: relative;
      transform-origin: center center;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #hint {
      color: #2a3550;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      text-align: center;
      margin-top: 5px;
      letter-spacing: 2px;
      transform-origin: center top;
    }
  </style>
</head>

<body>
  <div id="wrap"><canvas id="game" width="512" height="384"></canvas></div>
  <div id="hint">ARROWS · Z=SHOT/ACTION · X=SLICE · ESC=BACK</div>
  <script>
    'use strict';
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    const W = 512, H = 384;

    // Fullscreen responsive scaling
    function resizeGame() {
      const wrap = document.getElementById('wrap');
      const hint = document.getElementById('hint');
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const padding = 10;
      const hintH = 24;
      const availW = vw - padding * 2;
      const availH = vh - padding * 2 - hintH;
      const scale = Math.min(availW / W, availH / H);
      wrap.style.transform = `scale(${scale})`;
      hint.style.transform = `scale(${Math.min(scale, 2)})`;
    }
    window.addEventListener('resize', resizeGame);
    window.addEventListener('orientationchange', () => setTimeout(resizeGame, 100));
    resizeGame();

    // Sprite Sheets — uniform grid system
    const SHEET_COLS = 5, SHEET_ROWS = 4, FRAME_W = 128, FRAME_H = 160;
    const spr = new Image(); spr.src = 'marcos_sheet.png?v=2026';
    const oppSpr = new Image(); oppSpr.src = 'opponent_sheet_new.png?v=2026';
    const titleBg = new Image(); titleBg.src = 'title_bg_hd.png?v=2026';
    const introBg = new Image(); introBg.src = 'intro_bg.png?v=2026';
    const thumbs = {
      split: new Image(), pace: new Image(), smash: new Image(), toss: new Image(), spirit: new Image()
    };
    thumbs.split.src = 'thumb_split.png?v=2026';
    thumbs.pace.src = 'thumb_pace.png?v=2026';
    thumbs.smash.src = 'thumb_smash.png?v=2026';
    thumbs.toss.src = 'thumb_toss.png?v=2026';
    thumbs.spirit.src = 'thumb_spirit.png?v=2026';
    let sprLoaded = false, oppLoaded = false, titleBgLoaded = false;
    spr.onload = () => { sprLoaded = true; };
    oppSpr.onload = () => { oppLoaded = true; };
    titleBg.onload = () => { titleBgLoaded = true; };
    const FRAMES = {
      idle: [0, 0], run1: [1, 0], run2: [2, 0], forehand: [3, 0], backhand: [4, 0],
      serveUp: [0, 1], serveHit: [1, 1], fist: [2, 1], dive: [3, 1], stand: [4, 1],
      slice: [0, 2], volley: [1, 2], lob: [2, 2], splitStep: [3, 2], breathe: [4, 2],
      serve2: [0, 3], toss: [1, 3], celebrate: [2, 3], ready: [3, 3], recover: [4, 3]
    };
    function drawSpr(name, x, y, w, h, flipX = false, alpha = 1, sheet = null) {
      const img = sheet || spr, loaded = sheet ? oppLoaded : sprLoaded;
      ctx.save(); ctx.globalAlpha = alpha;
      if (!loaded) { ctx.fillStyle = sheet ? '#e03030' : '#f06020'; ctx.fillRect(x, y + h * 0.3, w, h * 0.7); ctx.fillStyle = '#c8906a'; ctx.fillRect(x + w * 0.25, y, w * 0.5, h * 0.35); ctx.restore(); return; }
      const f = FRAMES[name] || FRAMES.stand;
      const sx = f[0] * FRAME_W, sy = f[1] * FRAME_H;
      if (flipX) { ctx.translate(x + w, y); ctx.scale(-1, 1); ctx.drawImage(img, sx, sy, FRAME_W, FRAME_H, 0, 0, w, h); }
      else ctx.drawImage(img, sx, sy, FRAME_W, FRAME_H, x, y, w, h);
      ctx.restore();
    }

    // Input
    const Keys = {}, JP = {}, JR = {};
    document.addEventListener('keydown', e => {
      if (!Keys[e.code]) JP[e.code] = true;
      Keys[e.code] = true;
      e.preventDefault();
      // Resume AudioContext on first gesture
      const ac = ga();
      if (ac && ac.state === 'suspended') ac.resume();
    });
    document.addEventListener('keyup', e => { Keys[e.code] = false; JR[e.code] = true; });
    const clearInput = () => { for (let k in JP) delete JP[k]; for (let k in JR) delete JR[k]; };

    // Audio
    let AC = null;
    const ga = () => { if (!AC) try { AC = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { } return AC; };
    function tone(f, type = 'square', dur = 0.1, vol = 0.15, d = 0) {
      const ac = ga(); if (!ac) return;
      const o = ac.createOscillator(), g = ac.createGain();
      o.connect(g); g.connect(ac.destination);
      o.type = type; o.frequency.value = f;
      const t = ac.currentTime + d;
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + dur);
      o.start(t); o.stop(t + dur + 0.05);
    }
    function sfxHit() { tone(400, 'square', 0.06, 0.18); tone(600, 'square', 0.04, 0.1, 0.04); }
    function sfxTopspin() { tone(600, 'square', 0.05, 0.2); tone(800, 'sine', 0.08, 0.12, 0.03); }
    function sfxSlice() { tone(250, 'sawtooth', 0.1, 0.15); }
    function sfxBounce(surface) {
      if (surface === 'clay') { tone(140, 'sine', 0.09, 0.12); tone(90, 'sine', 0.06, 0.06, 0.03); }
      else if (surface === 'grass') { tone(220, 'sine', 0.05, 0.08); }
      else { tone(200, 'sine', 0.07, 0.1); tone(350, 'square', 0.03, 0.05, 0.02); }
    }
    function sfxNet() { tone(120, 'sawtooth', 0.15, 0.2); tone(80, 'sawtooth', 0.1, 0.1, 0.08); }
    function sfxWin() { [523, 659, 784, 1047].forEach((f, i) => tone(f, 'square', 0.14, 0.18, i * 0.1)); }
    function sfxFistPump() { [392, 523, 659, 784, 1047].forEach((f, i) => tone(f, 'square', 0.16, 0.2, i * 0.08)); }
    function sfxLose() { tone(180, 'sawtooth', 0.3, 0.2); }
    function sfxMenu() { tone(523, 'square', 0.06, 0.1); }
    function sfxAce() { tone(800, 'square', 0.06, 0.25); tone(1047, 'square', 0.08, 0.2, 0.06); tone(1318, 'sine', 0.12, 0.15, 0.12); }
    // NEW SFX
    function sfxMenuUp() { tone(587, 'square', 0.04, 0.08); }
    function sfxMenuDown() { tone(440, 'square', 0.04, 0.08); }
    function sfxConfirm() { tone(523, 'square', 0.06, 0.12); tone(784, 'square', 0.08, 0.12, 0.06); }
    function sfxCancel() { tone(330, 'sawtooth', 0.08, 0.1); tone(220, 'sawtooth', 0.06, 0.08, 0.05); }
    function sfxWhoosh() { tone(150 + Math.random() * 80, 'sawtooth', 0.06, 0.06); tone(300 + Math.random() * 100, 'sine', 0.04, 0.03, 0.02); }
    function sfxFootstep() { tone(80 + Math.random() * 40, 'sine', 0.03, 0.04); }
    function sfxCrowd() { for (let i = 0; i < 4; i++) tone(200 + Math.random() * 400, 'sine', 0.15 + Math.random() * 0.1, 0.02, i * 0.04); }
    function sfxUmpire(type) {
      if (type === 'point') { [660, 550, 440].forEach((f, i) => tone(f, 'square', 0.08, 0.08, i * 0.1)); }
      else if (type === 'game') { [440, 550, 660, 880].forEach((f, i) => tone(f, 'square', 0.1, 0.1, i * 0.12)); }
      else if (type === 'deuce') { [440, 440, 550].forEach((f, i) => tone(f, 'square', 0.12, 0.08, i * 0.15)); }
      else if (type === 'matchpoint') { [880, 660, 880, 1100].forEach((f, i) => tone(f, 'sine', 0.15, 0.1, i * 0.12)); }
    }
    function sfxMatchWin() { [523, 659, 784, 1047, 1318].forEach((f, i) => tone(f, 'square', 0.2, 0.2, i * 0.12));[523, 659, 784, 1047, 1318].forEach((f, i) => tone(f, 'sine', 0.25, 0.1, i * 0.12 + 0.05)); }

    // BGM — simple chiptune loop using oscillators
    let bgmPlaying = false, bgmNodes = [], bgmTimeout = null, bgmGen = 0;
    function startBGM() {
      const ac = ga(); if (!ac || bgmPlaying) return; 
      bgmPlaying = true; bgmGen++;
      const myGen = bgmGen;
      const melody = [523, 659, 784, 659, 523, 784, 659, 523, 587, 698, 784, 698, 587, 523, 440, 523];
      const bass = [262, 262, 330, 330, 349, 349, 262, 262];
      const loopDur = melody.length * 0.25;
      function playLoop() {
        if (!bgmPlaying || myGen !== bgmGen) return;
        const now = ac.currentTime;
        melody.forEach((f, i) => {
          const o = ac.createOscillator(), g = ac.createGain();
          o.connect(g); g.connect(ac.destination); o.type = 'square'; o.frequency.value = f;
          g.gain.setValueAtTime(0.04, now + i * 0.25); g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.25 + 0.22);
          o.start(now + i * 0.25); o.stop(now + i * 0.25 + 0.24); bgmNodes.push(o);
        });
        bass.forEach((f, i) => {
          const o = ac.createOscillator(), g = ac.createGain();
          o.connect(g); g.connect(ac.destination); o.type = 'triangle'; o.frequency.value = f;
          g.gain.setValueAtTime(0.03, now + i * 0.5); g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.5 + 0.45);
          o.start(now + i * 0.5); o.stop(now + i * 0.5 + 0.48); bgmNodes.push(o);
        });
        bgmTimeout = setTimeout(playLoop, loopDur * 1000);
      }
      playLoop();
    }
    function stopBGM() { 
      bgmPlaying = false; bgmGen++; 
      if (bgmTimeout) clearTimeout(bgmTimeout); 
      bgmNodes.forEach(n => { try { n.stop(); } catch (e) { } }); 
      bgmNodes = []; 
    }

    // Ambient court noise
    let ambientPlaying = false, ambientNodes = [];
    function startAmbient() {
      const ac = ga(); if (!ac || ambientPlaying) return; ambientPlaying = true;
      function ambLoop() {
        if (!ambientPlaying) return;
        const now = ac.currentTime;
        // Soft crowd murmur
        for (let i = 0; i < 3; i++) {
          const o = ac.createOscillator(), g = ac.createGain();
          o.connect(g); g.connect(ac.destination); o.type = 'sine';
          o.frequency.value = 120 + Math.random() * 200;
          g.gain.setValueAtTime(0.008, now + i * 0.3); g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.3 + 0.8);
          o.start(now + i * 0.3); o.stop(now + i * 0.3 + 0.85); ambientNodes.push(o);
        }
        setTimeout(ambLoop, 2500 + Math.random() * 2000);
      }
      ambLoop();
    }
    function stopAmbient() { ambientPlaying = false; ambientNodes.forEach(n => { try { n.stop(); } catch (e) { } }); ambientNodes = []; }

    // Screen transitions
    const Transition = {
      active: false, t: 0, dur: 0.4, callback: null,
      start(cb, dur = 0.4) { 
        if (this.active) return; 
        this.active = true; this.t = 0; this.dur = dur; this.callback = cb; 
      },
      update(dt) {
        if (!this.active) return;
        this.t += dt;
        if (this.t >= this.dur / 2 && this.callback) { this.callback(); this.callback = null; }
        if (this.t >= this.dur) this.active = false;
      },
      draw() {
        if (!this.active) return;
        const half = this.dur / 2;
        const alpha = this.t < half ? this.t / half : 1 - (this.t - half) / half;
        ctx.fillStyle = `rgba(6,10,20,${clamp(alpha, 0, 1)})`; ctx.fillRect(0, 0, W, H);
      }
    };
    function goTransition(s) { Transition.start(() => go(s)); }

    // Palette
    const C = {
      sky0: '#0d1b3e', court: '#3a8a5a', courtLine: '#f0eedc',
      gold: '#f0c040', orange: '#f06020', white: '#f0f0f0',
      dark: '#0a0e1a', accent: '#f0c040', red: '#e03030',
      green: '#30d050', cyan: '#40d8f0', purple: '#9040e0',
      ui: '#0c1220', uiBd: '#2a4080', txt: '#e8eeff', dim: '#4a5870',
      sand: '#e8c870', sandD: '#c8a850',
    };

    // Utils
    const lerp = (a, b, t) => a + (b - a) * t;
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    function px(x, y, w, h, c) { ctx.fillStyle = c; ctx.fillRect(~~x, ~~y, w, h); }
    function txt(s, x, y, c = '#fff', sz = 8, al = 'left') {
      ctx.fillStyle = c; ctx.font = `${sz}px 'Press Start 2P','Courier New',monospace`;
      ctx.textAlign = al; ctx.fillText(s, ~~x, ~~y); ctx.textAlign = 'left';
    }
    function bar(x, y, w, h, v, m, fg, bg = '#1a1a2a') { px(x, y, w, h, bg); px(x, y, ~~((v / m) * w), h, fg); px(x, y, w, 1, '#ffffff22'); }

    // Screen Shake
    const Shake = {
      x: 0, y: 0, str: 0,
      add(s) { this.str = Math.max(this.str, s); },
      update(dt) { if (this.str > 0) { this.str = Math.max(0, this.str - 8 * dt); this.x = (Math.random() - 0.5) * this.str * 3; this.y = (Math.random() - 0.5) * this.str * 3; } else { this.x = 0; this.y = 0; } },
      apply() { ctx.save(); ctx.translate(~~this.x, ~~this.y); },
      restore() { ctx.restore(); }
    };

    // Particles
    const Particles = {
      pool: [],
      emit(x, y, o = {}) {
        const n = o.count || 8;
        for (let i = 0; i < n; i++) {
          const a = (o.angle ?? Math.random() * Math.PI * 2) + (Math.random() - 0.5) * (o.spread ?? Math.PI * 2);
          const spd = (o.speed ?? 60) * (0.5 + Math.random() * 0.5);
          this.pool.push({
            x, y, vx: Math.cos(a) * spd, vy: Math.sin(a) * spd - (o.upward ?? 0) * 30,
            life: o.life ?? 0.5, maxLife: o.life ?? 0.5, size: o.size ?? (2 + Math.random() * 3),
            color: Array.isArray(o.color) ? o.color[~~(Math.random() * o.color.length)] : (o.color ?? '#fff'),
            gravity: o.gravity ?? 80, glow: o.glow ?? false
          });
        }
      },
      update(dt) { this.pool = this.pool.filter(p => { p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt; p.vy += p.gravity * dt; p.vx *= 0.95; return p.life > 0; }); },
      draw() {
        for (const p of this.pool) {
          const t = p.life / p.maxLife, s = Math.max(1, p.size * t);
          ctx.globalAlpha = t * 0.9;
          if (p.glow) { ctx.shadowColor = p.color; ctx.shadowBlur = 6; }
          ctx.fillStyle = p.color; ctx.fillRect(~~(p.x - s / 2), ~~(p.y - s / 2), ~~s || 1, ~~s || 1);
          if (p.glow) ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;
      }
    };

    // Floating text
    const Floats = {
      pool: [],
      add(s, x, y, color = C.gold, size = 10) { this.pool.push({ s, x, y, vy: -50, life: 1.2, maxLife: 1.2, color, size }); },
      update(dt) { this.pool = this.pool.filter(f => { f.life -= dt; f.y += f.vy * dt; f.vy *= 0.9; return f.life > 0; }); },
      draw() {
        for (const f of this.pool) {
          const t = f.life / f.maxLife;
          ctx.globalAlpha = t > 0.3 ? 1 : t / 0.3;
          ctx.save(); ctx.translate(~~f.x, ~~f.y); const sc = 1 + (1 - t) * 0.2; ctx.scale(sc, sc);
          txt(f.s, 0, 0, f.color, f.size, 'center'); ctx.restore();
        }
        ctx.globalAlpha = 1;
      }
    };

    // Ball trail
    const Trail = {
      hist: [],
      add(x, y, ps) {
        this.hist.push({ x, y, ps, t: 0 });
        if (this.hist.length > 12) this.hist.shift();
      },
      update(dt) {
        // Handle trail segment aging if needed
        for (const p of this.hist) p.t += dt;
      },
      draw() {
        ctx.save();
        for (let i = 0; i < this.hist.length; i++) {
          const p = this.hist[i];
          const alpha = (i / this.hist.length) * 0.45;
          const sz = (8 * p.ps) * (i / this.hist.length);
          ctx.fillStyle = `rgba(200,255,80,${alpha})`;
          if (i > 0) {
            const prev = this.hist[i - 1];
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y - sz / 2);
            ctx.lineTo(p.x, p.y - sz / 2);
            ctx.lineTo(p.x, p.y + sz / 2);
            ctx.lineTo(prev.x, prev.y + sz / 2);
            ctx.fill();
          }
          ctx.beginPath(); ctx.arc(p.x, p.y, sz, 0, Math.PI * 2); ctx.fill();
        }
        ctx.restore();
      }
    };

    // RPG Stats
    const Stats = {
      power: 25, agility: 25, stamina: 25, touch: 25, serve: 25, spin: 25, xp: 0, level: 1, coins: 50,
      gymChampionsDefeated: 0,
      addXP(amount, stat) {
        this.xp += amount;
        this.coins += ~~(amount * 1.5);
        if (stat && this[stat] < 99) this[stat] = Math.min(99, this[stat] + ~~(amount / 8));
        while (this.xp >= this.level * 100) { this.xp -= this.level * 100; this.level++; }
      }
    };

    // State machine
    let STATE = null;
    let freezeT = 0; // Global hit-stop freeze timer
    let curMap = 0; // 0 = Academy, 1 = City Gym
    let targetMap = 0;
    function go(s) { 
      if (STATE?.exit) STATE.exit(); 
      stopBGM(); 
      STATE = s; 
      if (STATE?.enter) STATE.enter(); 
    }

    // ═══ INTRO CUTSCENE ════════════════════════════════════
    const IntroCutsceneState = {
      t: 0, phase: 0, 
      lines: [
        "In the heart of the city...",
        "A legacy was born.",
        "One racket. One dream.",
        "To be the best at Baghdatis Academy."
      ],
      enter() { this.t = 0; this.phase = 0; startBGM(); },
      update(dt) {
        if (Transition.active) return;
        this.t += dt;
        if (JP['Enter'] || JP['KeyZ'] || JP['Space']) {
          this.t += 3; // Faster skip
        }
        if (this.t > 12) goTransition(HubState);
        if (JP['Escape']) goTransition(HomeState);
      },
      draw() {
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
        
        // Panning Background
        const scroll = this.t * 20;
        ctx.save();
        ctx.translate(-scroll % W, 0);
        ctx.drawImage(introBg, 0, 0, W, H);
        ctx.drawImage(introBg, W, 0, W, H);
        ctx.restore();

        // Cinematic Bars
        px(0, 0, W, 60, '#000');
        px(0, H - 60, W, 60, '#000');

        // Text Phases
        const lineIdx = Math.floor(this.t / 3);
        if (lineIdx < this.lines.length) {
          const lineT = (this.t % 3);
          const alpha = lineT < 0.5 ? lineT / 0.5 : (lineT > 2.5 ? 1 - (lineT - 2.5) / 0.5 : 1);
          ctx.globalAlpha = clamp(alpha, 0, 1);
          txt(this.lines[lineIdx], W / 2, H / 2 + 100, C.white, 8, 'center');
          ctx.globalAlpha = 1;
        }

        // Character Silhouette
        const charX = W / 2 + Math.sin(this.t) * 50;
        const breathe = Math.sin(this.t * 3) * 2;
        ctx.save();
        ctx.filter = 'brightness(0) shadow(0 0 10px rgba(59,130,246,0.5))';
        drawSpr('ready', charX - 32, H / 2 - 40 + breathe, 64, 80);
        ctx.restore();

        txt('SKIP: Z', W - 10, H - 10, C.dim, 6, 'right');
      }
    };

    // ═══ LOADING SCREEN ════════════════════════════════════
    const LoadingScreenState = {
      t: 0, transitioned: false,
      enter() { this.t = 0; this.transitioned = false; sfxFistPump(); },
      update(dt) {
        if (Transition.active || this.transitioned) return;
        this.t += dt;
        if (this.t > 4) { this.transitioned = true; goTransition(HubState); }
      },
      draw() {
        ctx.fillStyle = '#0a1020'; ctx.fillRect(0, 0, W, H);
        
        // Rolling road
        px(0, H / 2 + 20, W, 40, '#1a1a2a');
        for (let i = 0; i < 10; i++) {
          const ox = (i * 60 - this.t * 200) % (W + 60);
          px(ox, H / 2 + 38, 30, 4, '#ffffff44');
        }

        // Panning city silhouette
        ctx.fillStyle = '#050510';
        for (let i = 0; i < 8; i++) {
          const ox = (i * 80 - this.t * 50) % (W + 80);
          ctx.fillRect(ox, H / 2 - 40 - (i % 3) * 20, 60, 60);
        }

        // Bus
        const busX = W / 2 - 40 + Math.sin(this.t * 10) * 2;
        const busY = H / 2 - 10 + Math.abs(Math.sin(this.t * 15)) * 2;
        
        // Body
        px(busX, busY, 80, 32, '#2060c0'); 
        px(busX, busY, 80, 4, '#3080e0');
        px(busX, busY + 28, 80, 4, '#1a4a90');
        
        // Windows
        for (let wi = 0; wi < 5; wi++) px(busX + 6 + wi * 15, busY + 6, 11, 10, '#a0d8ff');
        
        // Wheels (spinning)
        ctx.fillStyle = '#222'; 
        const wheelRot = this.t * 20;
        [16, 64].forEach(off => {
          ctx.beginPath(); ctx.arc(busX + off, busY + 34, 6, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = '#444'; ctx.lineWidth = 2;
          ctx.beginPath(); 
          ctx.moveTo(busX + off, busY + 34); 
          ctx.lineTo(busX + off + Math.cos(wheelRot) * 6, busY + 34 + Math.sin(wheelRot) * 6); 
          ctx.stroke();
        });

        const msg = curMap === 1 ? "HEADING TO NEXT CITY..." : "RETURNING TO ACADEMY...";
        txt(msg, W / 2, H / 2 + 80, C.gold, 8, 'center');
        
        const prog = Math.min(1, this.t / 4);
        bar(W / 2 - 100, H / 2 + 100, 200, 4, prog * 100, 100, C.cyan);
      }
    };

    // ═══ PERSPECTIVE COURT ENGINE ═══════════════════════════
    const COURT = {
      TOP_Y: H * 0.10, BOT_Y: H * 0.88,
      toScreen(cx, cz) {
        const t = Math.max(-0.5, (cz + 1) / 2); // Clamp t to prevent negative scaling
        const sy = lerp(this.TOP_Y, this.BOT_Y, t * t * 0.3 + t * 0.7);
        const ps = Math.max(0.32, lerp(0.22, 1.0, t)); // Scaled up min size (0.22 -> 0.32)
        return { x: W / 2 + cx * W * 0.44 * ps, y: sy, ps };
      },
      draw() {
        // Sky
        const sg = ctx.createLinearGradient(0, 0, 0, H * 0.5);
        sg.addColorStop(0, '#0d1525'); sg.addColorStop(1, '#1a3a60');
        ctx.fillStyle = sg; ctx.fillRect(0, 0, W, H);
        // Crowd & stands
        px(0, 0, W, this.TOP_Y + 25, '#1a0808');
        // Crowd — animated bobbing heads
        for (let i = 0; i < 130; i++) {
          const colors = ['#c84040', '#4040c8', '#f0c040', '#40c840', '#c840c8', '#f08040'];
          const bob = Math.sin(this.t * 2.5 + i * 0.7) * 1.5;
          px((i * 73) % W, H * 0.02 + (i * 37) % (~~(H * 0.07)) + bob, 3, 5, colors[i % 6]);
        }
        // Stadium lights
        [[W * 0.12, H * 0.01], [W * 0.5, H * 0.005], [W * 0.88, H * 0.01]].forEach(([lx, ly]) => {
          ctx.save(); ctx.shadowColor = '#ffe8a0'; ctx.shadowBlur = 18; px(lx - 3, ly, 6, 4, '#fff8e0'); ctx.restore();
          ctx.globalAlpha = 0.05; ctx.beginPath(); ctx.moveTo(lx, ly + 4); ctx.lineTo(lx - 28, this.TOP_Y + 20); ctx.lineTo(lx + 28, this.TOP_Y + 20); ctx.closePath(); ctx.fillStyle = '#ffe8a0'; ctx.fill(); ctx.globalAlpha = 1;
        });
        // Court surface trapezoid
        const tl = this.toScreen(-1, -1), tr = this.toScreen(1, -1), bl = this.toScreen(-1, 1), br = this.toScreen(1, 1);
        ctx.beginPath(); ctx.moveTo(tl.x, tl.y); ctx.lineTo(tr.x, tr.y); ctx.lineTo(br.x, br.y); ctx.lineTo(bl.x, bl.y); ctx.closePath();
        ctx.fillStyle = C.court; ctx.fill();
        // Depth bands
        for (let i = 0; i < 7; i++) {
          const z = -1 + i * 0.29, z2 = z + 0.29;
          const l = this.toScreen(-1, z), r = this.toScreen(1, z), l2 = this.toScreen(-1, z2), r2 = this.toScreen(1, z2);
          ctx.beginPath(); ctx.moveTo(l.x, l.y); ctx.lineTo(r.x, r.y); ctx.lineTo(r2.x, r2.y); ctx.lineTo(l2.x, l2.y); ctx.closePath();
          ctx.fillStyle = i % 2 === 0 ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.02)'; ctx.fill();
        }
        this.drawLines(); this.drawNet();
        // Floor
        const fbl = this.toScreen(-1, 1), fbr = this.toScreen(1, 1);
        px(fbl.x, fbl.y, fbr.x - fbl.x, H - fbl.y, '#1a2a14');
        px(fbl.x, fbl.y, fbr.x - fbl.x, 2, '#ffffff22');
      },
      drawLines() {
        ctx.strokeStyle = C.courtLine; ctx.lineWidth = 1;
        const L = (x1, z1, x2, z2) => {
          const a = this.toScreen(x1, z1), b = this.toScreen(x2, z2);
          ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
        };
        L(-1, -1, 1, -1); L(-1, 1, 1, 1); L(-1, -1, -1, 1); L(1, -1, 1, 1);
        L(-0.72, -1, -0.72, 0); L(0.72, -1, 0.72, 0); L(-0.72, 0, -0.72, 1); L(0.72, 0, 0.72, 1);
        L(0, -1, 0, 1); L(-1, 0, 1, 0);
        ctx.globalAlpha = 0.25; L(-1, -1, -0.72, -1); L(0.72, -1, 1, -1); L(-1, 1, -0.72, 1); L(0.72, 1, 1, 1); ctx.globalAlpha = 1;
      },
      drawNet() {
        const nl = this.toScreen(-1.06, 0), nr = this.toScreen(1.06, 0);
        px(nl.x, nl.y + 2, nr.x - nl.x, 4, 'rgba(0,0,0,0.3)');
        [nl, nr].forEach(p => { px(p.x - 3, p.y - 20, 6, 24, '#888'); px(p.x - 2, p.y - 21, 4, 3, '#aaa'); });
        const segs = 22;
        for (let i = 0; i <= segs; i++) {
          const t = i / segs, cx2 = -1.06 + t * 2.12;
          const cp = this.toScreen(cx2, 0);
          ctx.strokeStyle = `rgba(220,215,200,${0.4 + t * 0.1})`; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(cp.x, cp.y); ctx.lineTo(cp.x, cp.y - 20 * cp.ps); ctx.stroke();
        }
        for (let r = 0; r <= 3; r++) {
          const f = r / 3;
          ctx.beginPath();
          for (let i = 0; i <= segs; i++) { const t = i / segs; const cp = this.toScreen(-1.06 + t * 2.12, 0); if (i === 0) ctx.moveTo(cp.x, cp.y - 20 * cp.ps * f); else ctx.lineTo(cp.x, cp.y - 20 * cp.ps * f); }
          ctx.strokeStyle = r === 3 ? 'rgba(255,255,255,0.85)' : 'rgba(200,195,180,0.45)';
          ctx.lineWidth = r === 3 ? 2 : 1; ctx.stroke();
        }
      },
      ballProj(cx, cz, ch) {
        const s = this.toScreen(cx, cz);
        return { x: s.x, y: s.y - ch * s.ps * 55, sx: s.x, sy: s.y, ps: s.ps };
      }
    };

    // ═══ HOME SCREEN ═════════════════════════════════════════
    const HomeState = {
      t: 0, phase: 'intro', introT: 0,
      ball: { x: 110, y: 220, vx: 95, vy: -65, z: 0, vz: 85 },
      sel: 0, blink: 0,
      items: ['▶  NEW GAME', '    TRAINING', '    OPTIONS'],
      enter() { this.t = 0; this.introT = 0; this.phase = 'intro'; this.sel = 0; Particles.pool = []; startBGM(); },
      exit() { stopBGM(); },
      update(dt) {
        this.t += dt; this.blink += dt; this.introT += dt;
        if (this.phase === 'intro' && this.introT > 2.5) this.phase = 'menu';
        const b = this.ball;
        b.x += b.vx * dt; b.y += b.vy * dt; b.z += b.vz * dt; b.vz -= 220 * dt; b.vy -= 8 * dt;
        if (b.z <= 0) { b.z = 0; b.vz = Math.abs(b.vz) * 0.75; if (Math.abs(b.vz) < 10) b.vz = 55; sfxBounce(); Particles.emit(b.x, b.y, { count: 5, color: ['#c8ff40', '#ffff60'], speed: 28, life: 0.3, upward: 1 }); }
        if (b.x < 28 || b.x > W - 28) { b.vx *= -0.9; }
        if (b.y < 65 || b.y > H - 55) b.vy *= -0.8;
        Particles.update(dt); Floats.update(dt);
        if (this.phase === 'menu') {
          if (JP['ArrowUp']) { this.sel = (this.sel - 1 + 3) % 3; sfxMenuUp(); }
          if (JP['ArrowDown']) { this.sel = (this.sel + 1) % 3; sfxMenuDown(); }
          if (JP['Enter'] || JP['KeyZ']) {
            if (this.sel === 0) { sfxConfirm(); goTransition(IntroCutsceneState); }
            else if (this.sel === 1) { sfxConfirm(); goTransition(TrainingSelectState); }
            else sfxMenu();
          }
          if (JP['Escape']) sfxCancel();
        }
      },
      draw() {
        if (titleBgLoaded) { ctx.drawImage(titleBg, 0, 0, W, H); ctx.fillStyle = 'rgba(6,10,20,0.55)'; ctx.fillRect(0, 0, W, H); }
        else { const bg = ctx.createRadialGradient(W / 2, H * 0.4, 20, W / 2, H * 0.4, 300); bg.addColorStop(0, '#0d1525'); bg.addColorStop(1, '#060a10'); ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H); }
        // Grid
        ctx.strokeStyle = 'rgba(40,80,160,0.13)'; ctx.lineWidth = 1;
        for (let x = 0; x < W; x += 24) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
        for (let y = 0; y < H; y += 24) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
        // Glow orbs
        for (let i = 0; i < 3; i++) {
          const r = 80 + Math.sin(this.t * 0.7 + i * 2) * 30;
          ctx.fillStyle = `rgba(240,180,40,${0.035 + Math.sin(this.t * 0.5 + i) * 0.015})`;
          ctx.beginPath(); ctx.arc(W / 2, H * 0.35, r + i * 60, 0, Math.PI * 2); ctx.fill();
        }
        // Animated Title — letters bounce in
        const titleLetters = 'BAGHDATIS';
        const subLetters = 'ACADEMY';
        ctx.save();
        for (let i = 0; i < titleLetters.length; i++) {
          const delay = i * 0.08;
          const prog = clamp((this.t - delay) * 3, 0, 1);
          const bounce = prog < 1 ? Math.sin(prog * Math.PI) * 8 : 0;
          const alpha = clamp(prog * 2, 0, 1);
          ctx.globalAlpha = alpha; ctx.shadowColor = C.gold; ctx.shadowBlur = 20 + bounce;
          const spacing = 22; // Increased from 11
          const x = W / 2 - (titleLetters.length * spacing) / 2 + i * spacing + 5;
          txt(titleLetters[i], x, H * 0.2 - bounce, C.gold, 20, 'left');
        }
        ctx.shadowBlur = 15;
        for (let i = 0; i < subLetters.length; i++) {
          const delay = titleLetters.length * 0.08 + i * 0.06;
          const prog = clamp((this.t - delay) * 3, 0, 1);
          const bounce = prog < 1 ? Math.sin(prog * Math.PI) * 5 : 0;
          ctx.globalAlpha = clamp(prog * 2, 0, 1);
          const spacing = 18; // Increased from 9
          const x = W / 2 - (subLetters.length * spacing) / 2 + i * spacing + 4;
          txt(subLetters[i], x, H * 0.2 + 28 - bounce, '#f8a030', 16, 'left');
        }
        ctx.shadowBlur = 8; ctx.shadowColor = '#c0e0ff';
        const subProg = clamp((this.t - 1.2) * 2, 0, 1);
        ctx.globalAlpha = subProg;
        txt('PIXEL PATHWAY', W / 2, H * 0.2 + 52, C.cyan, 8, 'center');
        ctx.restore();
        px(W / 2 - 120, ~~(H * 0.23 + 62), 240, 1, C.gold + '88');
        // Marcos sprite — idle breathing
        const breathe = Math.sin(this.t * 2.5) * 2;
        const frame = ~~(this.t * 4) % 3;
        drawSpr(['idle', 'run1', 'run2'][frame], W * 0.62, H * 0.28 + breathe, 52, 68);
        ctx.fillStyle = 'rgba(0,0,0,0.22)'; ctx.beginPath(); ctx.ellipse(W * 0.62 + 26, H * 0.28 + 70, 20, 5, 0, 0, Math.PI * 2); ctx.fill();
        // Demo ball
        const bs = 7 + Math.sin(this.t * 8) * 1;
        const bh = Math.max(0, this.ball.z * 0.3);
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(this.ball.x, this.ball.y + 4, bs * 0.8, 3, 0, 0, Math.PI * 2); ctx.fill();
        ctx.save(); ctx.shadowColor = '#c8ff40'; ctx.shadowBlur = 8;
        px(this.ball.x - bs / 2, this.ball.y - bs / 2 - bh, bs, bs, '#c8ff40'); ctx.restore();
        Particles.draw();
        // Menu with pulse/glow animation
        if (this.phase === 'menu') {
          px(W / 2 - 116, H * 0.66 - 4, 232, 76, 'rgba(6,10,20,0.92)'); px(W / 2 - 116, H * 0.66 - 4, 232, 1, C.gold + '88');
          this.items.forEach((item, i) => {
            const y = H * 0.66 + 16 + i * 22, sel = i === this.sel;
            if (sel) {
              const pulse = 0.08 + Math.sin(this.t * 6) * 0.04;
              px(W / 2 - 110, y - 12, 220, 17, `rgba(240,192,64,${pulse})`);
              ctx.save(); ctx.shadowColor = C.gold; ctx.shadowBlur = 8;
              txt(item, W / 2 - 100, y, C.accent, 8);
              ctx.restore();
            } else {
              txt(item, W / 2 - 100, y, C.dim, 8);
            }
            if (sel) txt('◀', W / 2 + 96, y, C.gold, 8);
          });
        } else if (~~(this.blink * 2) % 2 === 0) {
          txt('PRESS ENTER', W / 2, H * 0.74, C.white, 9, 'center');
        }
        px(0, H - 18, W, 18, 'rgba(0,0,0,0.8)'); px(0, H - 18, W, 1, C.uiBd);
        txt('CITY OF DREAMS RESORT  |  V2.0', W / 2, H - 5, C.dim, 6, 'center');
        if (this.phase === 'intro') {
          const al = Math.max(0, 1 - this.introT * 0.8);
          ctx.fillStyle = `rgba(6,10,20,${al})`; ctx.fillRect(0, 0, W, H);
          if (this.introT < 1.8) {
            ctx.globalAlpha = Math.min(1, this.introT * 1.5);
            ctx.save(); ctx.shadowColor = C.gold; ctx.shadowBlur = 40;
            txt('BAGHDATIS', W / 2, H / 2 - 14, C.gold, 22, 'center'); txt('ACADEMY', W / 2, H / 2 + 16, C.orange, 16, 'center'); ctx.restore(); ctx.globalAlpha = 1;
          }
        }
      }
    };

    // ═══ MATCH STATE — Perspective Court ════════════════════
    const MatchState = {
      t: 0, phase: 'intro', introT: 0,
      ball: { cx: 0, cz: 0.5, ch: 0, vcx: 0, vcz: 0, vch: 0, spin: 0, active: false },
      p: { cx: 0, cz: 0.85, anim: 'stand', animT: 0, facing: 1, swing: false, swingT: 0, swingType: 'flat', stamina: 100, charge: 0 },
      o: { cx: 0, cz: -0.75, anim: 'stand', animT: 0, swing: false, swingT: 0, returnCooldown: 0 },
      oppName: 'ROOKIE', oppLevel: 1,
      pPts: 0, oPts: 0, pGames: 0, oGames: 0, pSets: 0, oSets: 0,
      rally: 0, lastHit: 'none', bounced: 0, serving: true, server: 'player',
      ptMsg: '', ptMsgT: 0, hitFlash: 0, matchWinner: null,
      deadBallTimer: 0, pointScored: false,
      surface: 'hard', // 'hard', 'clay', 'grass'
      aceTimer: 0, // Track time for ace detection
      surfStats: {
        hard: {
          bounce: 0.88, friction: 0.92, speed: 1.05, color: '#4060c0',
          particles: ['#6080e0', '#80a0ff', '#fff'], pName: 'HARD'
        },
        clay: {
          bounce: 0.95, friction: 0.68, speed: 0.88, color: '#d06040',
          particles: ['#d08050', '#e0a060', '#c87040'], pName: 'CLAY'
        },
        grass: {
          bounce: 0.76, friction: 1.05, speed: 1.12, color: '#40a040',
          particles: ['#40c050', '#60e060', '#80ff80'], pName: 'GRASS'
        }
      },

      enter() {
        this.t = 0; this.phase = 'play'; this.introT = 0;
        this.p.cx = 0; this.p.cz = 0.85; this.p.stamina = 100; this.p.swing = false; this.p.charge = 0;
        this.o.cx = 0; this.o.cz = -0.75; this.o.swing = false; this.o.returnCooldown = 0;
        this.pPts = 0; this.oPts = 0; this.pGames = 0; this.oGames = 0;
        this.rally = 0; this.matchWinner = null; this.pointScored = false;
        this.serving = true; this.server = 'player'; this.deadBallTimer = 0;
        this.netWobble = 0; this.footT = 0;
        this.smashStar = null; this.specialGauge = 0;
        
        // Initialize Opponent based on map
        if (curMap === 0) {
          this.oppName = "ACADEMY ROOKIE";
          this.oppLevel = 1;
        } else {
          const names = ["IRON MIKE", "SHADOW STEP", "GRAND CHAMPION"];
          this.oppName = names[Math.min(2, Stats.gymChampionsDefeated)];
          this.oppLevel = 5 + Stats.gymChampionsDefeated * 5;
        }

        Trail.hist = []; Particles.pool = []; Floats.pool = [];
        this.surface = ['hard', 'clay', 'grass'][~~(Math.random() * 3)];
        this.resetBallForServe();
        startAmbient();
      },
      exit() { stopAmbient(); },

      resetBallForServe() {
        const b = this.ball;
        b.active = false; b.ch = 0; b.vcx = 0; b.vcz = 0; b.vch = 0; b.spin = 0;
        this.bounced = 0; this.lastHit = 'none'; this.pointScored = false;
        this.deadBallTimer = 0; this.serving = true; this.tossed = false; this.t = 0;
        Trail.hist = [];
        if (this.server === 'player') {
          b.cx = 0.15; b.cz = 0.9;
          this.p.cx = 0.15; this.p.cz = 0.88;
        } else {
          b.cx = 0; b.cz = -0.85;
          this.o.cx = 0; this.o.cz = -0.75;
        }
      },

      doServe(side, perfect = false) {
        const b = this.ball;
        const surf = this.surfStats[this.surface];
        b.active = true; this.serving = false; this.bounced = 0;
        this.aceTimer = 0; // Start ace detection timer
        if (side === 'player') {
          const sv = (1.2 + Stats.serve * 0.008) * surf.speed;
          b.cx = this.p.cx; b.cz = this.p.cz;
          b.ch = 0.8; b.vch = perfect ? 0.85 : 1.1;
          b.vcz = -(sv + Math.random() * 0.15);
          b.vcx = (Math.random() - 0.5) * 0.25;
          b.spin = perfect ? 0.5 : 0.2; // Perfect serve = more topspin kick
          this.lastHit = 'player';
          this.p.anim = 'serveHit'; this.p.animT = 0.5;
          sfxTopspin(); Shake.add(perfect ? 8 : 4); freezeT = perfect ? 0.15 : 0.08;
          Floats.add(perfect ? 'PERFECT SERVE!' : 'SERVE!', COURT.toScreen(this.p.cx, this.p.cz).x, COURT.toScreen(this.p.cx, this.p.cz).y - 45, perfect ? C.gold : C.white, perfect ? 12 : 9);
          Particles.emit(...this.bsp(), { count: perfect ? 25 : 10, color: perfect ? [C.gold, '#fff', '#ffe080'] : [C.gold, '#fff'], speed: perfect ? 90 : 60, life: perfect ? 0.6 : 0.4, glow: true });
          if (perfect) { b.vcz *= 1.35; b.vch *= 0.7; } // Perfect = flatter + faster
        } else {
          const oSv = (1.0 + this.oGames * 0.03) * surf.speed;
          b.cx = this.o.cx; b.cz = this.o.cz;
          b.ch = 0.75; b.vch = 0.95;
          b.vcz = oSv + Math.random() * 0.2;
          b.vcx = (this.p.cx * 0.35 + (Math.random() - 0.5) * 0.3);
          b.spin = (Math.random() - 0.5) * 0.3;
          this.lastHit = 'opponent';
          this.o.anim = 'serveHit'; this.o.animT = 0.5;
          sfxHit();
        }
      },

      opponentHit() {
        const o = this.o, b = this.ball, p = this.p;
        o.swing = true; o.swingT = 0; o.returnCooldown = 0.5;
        this.lastHit = 'opponent'; this.rally++; this.hitFlash = 0.1;
        freezeT = 0.05;

        // Target selection logic
        let targetX = (Math.random() - 0.5) * 0.8;
        if (this.rally > 4) {
          targetX = p.cx > 0 ? -0.8 - Math.random() * 0.2 : 0.8 + Math.random() * 0.2;
        } else {
          targetX = (Math.random() - 0.5) * 0.4;
        }

        const lvlMod = 1.0 + (this.oppLevel * 0.04);
        b.vcx = (targetX - b.cx) * 0.75;
        b.vcz = (1.0 + Math.random() * 0.2) * lvlMod;
        b.vch = 0.65 + Math.random() * 0.3;
        b.spin = (Math.random() - 0.5) * 0.4 * lvlMod;
        b.active = true; this.bounced = 0;

        o.anim = b.cx < o.cx ? 'backhand' : 'forehand'; o.animT = 0.4;
        sfxHit();
        this.specialGauge = Math.min(100, (this.specialGauge || 0) + 4);

        // Lob check for Smash Star
        if (b.vch > 0.85) {
          const t = Math.abs(b.vch / 0.5) * 1.5;
          this.smashStar = { cx: b.cx + b.vcx * t, cz: b.cz + b.vcz * t, t: 2.5 };
        }

        Floats.add(this.rally > 8 ? 'GREAT RETURN!' : 'RETURN!', COURT.toScreen(o.cx, o.cz).x, COURT.toScreen(o.cx, o.cz).y - 30, '#f05050', 7);
      },

      scorePoint(winner) {
        if (this.pointScored) return;
        this.pointScored = true;
        this.ball.active = false;
        freezeT = 0.25;
        this.ptMsgT = 2.2; Shake.add(winner === 'player' ? 5 : 3);
        if (winner === 'player') {
          this.pPts++; this.ptMsg = 'YOUR POINT!'; sfxWin();
          sfxCrowd(); sfxUmpire('point');
          Particles.emit(W / 2, H * 0.55, { count: 22, color: [C.gold, C.orange, '#fff'], speed: 85, life: 0.8, upward: 2, glow: true, spread: Math.PI * 2 });
          Floats.add('POINT!', W / 2, H * 0.5, C.gold, 12);
        } else {
          this.oPts++; this.ptMsg = 'OPPONENT POINT'; sfxLose(); sfxUmpire('point');
        }
        const pp = this.pPts, op = this.oPts;
        const pWinsGame = pp >= 4 && pp - op >= 2;
        const oWinsGame = op >= 4 && op - pp >= 2;
        if (pWinsGame) {
          this.pGames++; this.pPts = 0; this.oPts = 0;
          sfxFistPump(); sfxCrowd(); sfxUmpire('game'); this.ptMsg = 'GAME!';
          Floats.add('GAME!', W / 2, H * 0.38, C.gold, 14);
          this.server = this.server === 'player' ? 'opponent' : 'player';
        } else if (oWinsGame) {
          this.oGames++; this.pPts = 0; this.oPts = 0;
          this.ptMsg = 'OPP GAME';
          Floats.add('OPP GAME', W / 2, H * 0.38, '#f05050', 12);
          this.server = this.server === 'player' ? 'opponent' : 'player';
        }
        if (this.pGames >= 6 && this.pGames - this.oGames >= 2) {
          this.matchWinner = 'player'; this.phase = 'results'; sfxMatchWin(); sfxCrowd(); return;
        }
        if (this.oGames >= 6 && this.oGames - this.pGames >= 2) {
          this.matchWinner = 'opponent'; this.phase = 'results'; sfxLose(); return;
        }
        this.rally = 0; this.deadBallTimer = 1.8;
      },

      playerHit(type) {
        const p = this.p, b = this.ball;
        const surf = this.surfStats[this.surface];
        if (!b.active || this.pointScored) return;
        const d = Math.sqrt((b.cx - p.cx) ** 2 + (b.cz - p.cz) ** 2);

        let lunge = false;
        if (d > 0.45) {
          if (d < 0.72 && b.ch < 0.5) lunge = true;
          else return;
        }

        const isSpecial = this.specialGauge >= 100 && (JP['KeyC'] || JP['KeyQ']);
        if (isSpecial) {
          this.specialGauge = 0;
          this.hitFlash = 0.25;
          sfxAce(); Shake.add(15); freezeT = 0.2;
          Floats.add('ULTRA SPECIAL!', COURT.toScreen(this.p.cx, this.p.cz).x, COURT.toScreen(this.p.cx, this.p.cz).y - 65, C.cyan, 14);
        }

        let isSmash = false;
        if (this.smashStar && type !== 'lob') {
          const dist = Math.sqrt((p.cx - this.smashStar.cx) ** 2 + (p.cz - this.smashStar.cz) ** 2);
          if (dist < 0.3) isSmash = true;
        }

        freezeT = lunge ? 0.04 : (isSmash ? 0.2 : 0.08);
        const pc = (p.charge || 0);
        const chargeScale = 1 + pc * 0.7;
        const perfectCharge = pc > 0.9;
        if (perfectCharge && !isSpecial && !isSmash) {
          Floats.add('PERFECT!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 65, C.gold, 12);
          freezeT = 0.12;
        }
        p.charge = 0;

        const pwrMult = (0.7 + (Stats.power || 25) * 0.01) * (isSmash ? 1.6 : 1) * (isSpecial ? 2.3 : 1) * (chargeScale || 1);
        const spinMult = 1.0 + (Stats.spin || 25) * 0.008;
        const baseVcz = -1.15 * (surf.speed || 1) * pwrMult;
        const aimX = (JP['ArrowLeft'] || Keys['ArrowLeft'] ? -0.8 : (JP['ArrowRight'] || Keys['ArrowRight'] ? 0.8 : (Math.random() - 0.5) * 0.3));

        b.active = true; b.vcx = (aimX - b.cx) * 0.8;
        this.lastHit = 'player';

        if (type === 'topspin' && !lunge) {
          b.spin = (0.6 + (perfectCharge ? 0.4 : 0)) * spinMult;
          b.vcz = baseVcz * 1.05; b.vch = 0.55 - (perfectCharge ? 0.15 : 0);
          sfxTopspin(); Shake.add(perfectCharge ? 8 : 4);
          Particles.emit(...this.bsp(), { count: perfectCharge ? 25 : 14, color: ['#c8ff40', '#fff'], speed: 80, life: 0.6, glow: true });
          Floats.add(perfectCharge ? 'POWER TOPSPIN!' : 'TOPSPIN!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 35, C.green, 9);
        } else if (type === 'slice' && !lunge) {
          b.spin = -(0.5 + (perfectCharge ? 0.3 : 0)) * spinMult;
          b.vcz = baseVcz * 0.75; b.vch = 0.7; // Floats more
          sfxSlice(); Shake.add(perfectCharge ? 5 : 2);
          Floats.add(perfectCharge ? 'HEAVY SLICE!' : 'SLICE!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 35, C.cyan, 9);
        } else if (type === 'lob' && !lunge) {
          b.vcz = baseVcz * 0.55; b.vch = 2.2 + (perfectCharge ? 0.8 : 0); // Much higher lob
          sfxHit(); Shake.add(2);
          Floats.add('HIGH LOB!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 35, '#ff80ff', 9);
        } else if (type === 'drop' && !lunge) {
          b.vcz = baseVcz * 0.32; b.vch = 0.28; b.spin = -0.6 * spinMult;
          sfxSlice(); Shake.add(1);
          Floats.add('DROP!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 35, C.orange, 9);
        } else {
          b.vcz = (lunge ? baseVcz * 0.5 : baseVcz * 1.15);
          b.vch = lunge ? 0.9 : 0.4 - (perfectCharge ? 0.1 : 0);
          sfxHit(); Shake.add(perfectCharge ? 7 : (lunge ? 3 : 2));
          if (perfectCharge && !lunge) Floats.add('WINNER!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 35, '#fff', 12);
          if (lunge) Floats.add('LUNGE!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 35, C.white, 7);
        }

        if (isSmash) {
          b.vcz *= 1.45; b.vch = 0.12; b.vcx *= 1.1;
          this.smashStar = null; this.hitFlash = 0.18;
          sfxAce(); Shake.add(12);
          Floats.add('SUPER SMASH!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 55, C.gold, 14);
        }
        if (isSpecial) {
          b.vcz *= 1.4; b.vcx *= 1.15; b.vch = 0.1;
          Particles.emit(...this.bsp(), { count: 35, color: [C.cyan, '#fff'], speed: 130, life: 0.8, glow: true });
        }

        b.bounced = 0; this.rally++;
        p.stamina = Math.max(0, p.stamina - (lunge ? 12 : 4));
        this.specialGauge = Math.min(100, (this.specialGauge || 0) + 6 + (perfectCharge ? 6 : 0));
        p.anim = lunge ? 'dive' : (b.cx < p.cx ? 'backhand' : 'forehand');
        p.animT = 0.45;
      },



      bsp() { const bp = COURT.ballProj(this.ball.cx, this.ball.cz, this.ball.ch); return [bp.x, bp.y]; },

      update(dt) {
        if (freezeT > 0) { freezeT -= dt; return; } // Global freeze for hit stop
        this.t += dt; this.introT += dt;
        Shake.update(dt); Particles.update(dt); Floats.update(dt); Trail.update(dt);
        if (this.hitFlash > 0) this.hitFlash -= dt;
        if (this.ptMsgT > 0) this.ptMsgT -= dt;
        if (this.phase === 'intro') { if (this.introT > 2.5 || JP['Enter'] || JP['KeyZ']) this.phase = 'play'; return; }
        if (this.phase === 'results') {
          if (JP['Enter'] || JP['KeyZ']) { 
            const won = this.matchWinner === 'player';
            if (won && curMap === 1) Stats.gymChampionsDefeated++;
            Stats.addXP(won ? 80 : 20, 'agility'); 
            go(HubState); 
          }
          return;
        }
        const b = this.ball, p = this.p, o = this.o;
        let moving = false;
        const charging = (Keys['KeyZ'] || Keys['KeyX'] || Keys['Space']) && !this.pointScored && !this.serving;

        // Dead ball timer (between points)
        if (this.deadBallTimer > 0) {
          this.deadBallTimer -= dt;
          if (this.deadBallTimer <= 0) this.resetBallForServe();
          // Still allow player movement during dead ball
          const ps2 = (Stats.agility * 0.008 + 0.65) * dt * 0.5;
          if (Keys['ArrowLeft']) p.cx = Math.max(-0.95, p.cx - ps2);
          if (Keys['ArrowRight']) p.cx = Math.min(0.95, p.cx + ps2);
          if (JP['Escape']) goTransition(HubState);
          // (Continue to physics below instead of returning)
        } else if (this.serving) {
          if (this.server === 'player') {
            if (!this.tossed) {
              const ps2 = (Stats.agility * 0.008 + 0.65) * dt * 0.5;
              if (Keys['ArrowLeft']) p.cx = Math.max(-0.5, p.cx - ps2);
              if (Keys['ArrowRight']) p.cx = Math.min(0.5, p.cx + ps2);
              b.cx = p.cx; b.cz = p.cz; b.ch = 0.4;
              p.anim = 'serveUp'; p.animT = 0.2; p.facing = 1;
              if (JP['KeyZ'] || JP['KeyX'] || JP['Space']) {
                this.tossed = true; b.active = true;
                b.vch = 3.2; b.vcz = 0; b.vcx = 0; // Much higher toss
                sfxMenu();
                Floats.add('TOSS!', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 60, C.cyan, 8);
              }
            } else {
              // Ball in air, wait for strike
              const dist = Math.sqrt((b.cx - p.cx) ** 2 + (b.cz - p.cz) ** 2);
              const strikeKey = JP['KeyZ'] || JP['KeyX'] || JP['Space'];
              const holdKey = Keys['KeyZ'] || Keys['KeyX'] || Keys['Space'];
              if (dist < 0.58 && b.ch > 1.15 && (strikeKey || (holdKey && b.vch < 0.5))) {
                const perfect = b.ch > 1.5 && b.vch < 0.3; // Near peak
                this.doServe('player', perfect);
              }
              // Failed toss
              if (b.ch <= 0 && b.vch < 0) {
                this.resetBallForServe();
                Floats.add('FAULT!', W / 2, H / 2, C.red, 10);
              }
            }
          } else {
            // Opponent auto-serves after a short delay
            o.anim = 'serveUp'; o.animT = 0.2;
            if (this.t > 1.5) this.doServe('opponent');
          }
          if (JP['Escape']) goTransition(HubState);
        } else {
          // Regular Match Logic (only if NOT serving)
          // Player movement
          const ps = (Stats.agility * 0.008 + 0.65) * dt;
          if (Keys['ArrowLeft']) { p.cx = Math.max(-0.95, p.cx - ps); moving = true; }
          if (Keys['ArrowRight']) { p.cx = Math.min(0.95, p.cx + ps); moving = true; }
          if (Keys['ArrowUp']) { p.cz = Math.max(0.48, p.cz - ps * 0.7); moving = true; }
          if (Keys['ArrowDown']) { p.cz = Math.min(0.95, p.cz + ps * 0.7); moving = true; }

          // Orientation Logic
          if (b.active) p.facing = b.cx < p.cx ? -1 : 1;

          // Footstep SFX
          if (moving) {
            this.footT = (this.footT || 0) + dt;
            if (this.footT > 0.15) { sfxFootstep(); this.footT = 0; }
          }

          // Swing whoosh SFX
          if (this.p.animT > 0 && this.p.animT < 0.05 && (this.p.anim === 'forehand' || this.p.anim === 'backhand' || this.p.anim === 'serveHit')) sfxWhoosh();

          // Shot Charging
          if (charging && b.active) {
            p.charge = Math.min(1, p.charge + 0.8 * dt);
            if (p.charge > 0.1 && ~~(this.t * 10) % 2 === 0) {
              const screen = COURT.toScreen(p.cx, p.cz);
              Particles.emit(screen.x, screen.y, { count: 1, color: [C.gold, '#fff'], speed: 10, life: 0.4, upward: 1 });
            }
          } else if (!charging) {
            p.charge = Math.max(0, p.charge - 2 * dt);
          }

          // Apply Hits — triggered on RELEASE (JR) for charge mechanic
          if (b.active && !this.pointScored && this.lastHit !== 'player') {
            const pd = Math.sqrt((b.cx - p.cx) ** 2 + (b.cz - p.cz) ** 2);
            // Slightly wider reach for comfort
            if (pd < 0.52 && b.ch < 0.65) {
              if (JR['KeyZ']) {
                if (Keys['ArrowUp']) this.playerHit('lob');
                else if (Keys['ArrowDown']) this.playerHit('drop');
                else this.playerHit('topspin');
              } else if (JR['KeyX']) this.playerHit('slice');
              else if (JR['Space']) this.playerHit('flat');
            }
          }

          if (moving) {
            p.animT += dt; if (p.animT > 0.12) { p.anim = p.anim === 'run1' ? 'run2' : 'run1'; p.animT = 0; }
          } else if (p.anim !== 'dive' || p.animT <= 0) {
            p.anim = charging ? 'backhand' : 'stand';
          }

          if (charging) txt('CHARGING', COURT.toScreen(p.cx, p.cz).x, COURT.toScreen(p.cx, p.cz).y - 50, C.gold, 5, 'center');

          if (p.animT > 0) p.animT -= dt;
          if (o.animT > 0) o.animT -= dt;
          else if (!o.swing) o.anim = 'stand';
          if (!moving && p.stamina < 100) p.stamina = Math.min(100, p.stamina + 3 * dt);

          if (!this.pointScored) {
            // Redundant hit block removed
          }

          // AI Logic — designed for sustained rallies
          if (o.returnCooldown > 0) o.returnCooldown -= dt;
          const ballComingToOpp = b.vcz < 0;
          // AI balancing: scales with opponent level and game count
          const diffMod = Math.min(2.5, (this.oppLevel * 0.08) + (this.oGames * 0.05));
          const oSpeed = (0.75 + diffMod) * dt;
          if (ballComingToOpp && b.active) {
            // Better prediction: use more of actual ball trajectory
            const timeToReach = Math.abs((o.cz - b.cz) / (b.vcz || -0.01));
            const predictX = b.cx + b.vcx * Math.min(2.5, timeToReach) * 0.85;
            const targetX = clamp(predictX || 0, -0.88, 0.88);
            const diff = targetX - o.cx;
            o.cx += Math.sign(diff) * Math.min(Math.abs(diff), oSpeed * 1.6);
            if (isNaN(o.cx)) o.cx = 0; // Emergency recovery
            // Better depth positioning
            let targetZ = -0.72;
            if (b.vch > 0.6 || b.ch > 0.5) targetZ = -0.82;
            else if (b.vcz > -0.6 && b.cz < -0.1) targetZ = -0.55;
            const zDiff = targetZ - o.cz;
            o.cz += Math.sign(zDiff) * Math.min(Math.abs(zDiff), oSpeed * 0.7);
          } else if (b.active) {
            // Return to center when ball going away
            o.cx += Math.sign(0 - o.cx) * Math.min(Math.abs(0 - o.cx), oSpeed * 0.6);
            o.cz += Math.sign(-0.72 - o.cz) * Math.min(Math.abs(-0.72 - o.cz), oSpeed * 0.4);
          }
          o.cx = clamp(o.cx, -0.95, 0.95);

          // Wider hit detection for opponent — essential for rally sustain
          if (b.active && !this.pointScored && o.returnCooldown <= 0) {
            const od = Math.sqrt((b.cx - o.cx) ** 2 + (b.cz - o.cz) ** 2);
            if (od < 0.45 && b.ch < 0.45 && this.lastHit === 'player' && b.vcz < 0) this.opponentHit();
          }
        }

        // Global Match Elements (Physics & Escape)
        if (JP['Escape']) goTransition(HubState);


        // Ball physics
        if (b.active) {
          const surf = this.surfStats[this.surface];

          // Spin-modified gravity: topspin dips harder, slice floats longer
          const spinGravity = 2.0 + b.spin * 1.5; // Reduced gravity for more air time
          b.ch += b.vch * dt; b.vch -= spinGravity * dt;

          // Spin lateral drift (curve ball effect)
          b.vcx += b.spin * 0.15 * Math.sign(b.vcz) * dt;

          // Air resistance (quadratic-ish drag — faster balls slow more)
          const speed = Math.sqrt(b.vcx * b.vcx + b.vcz * b.vcz);
          const dragCoeff = 0.12 + speed * 0.07;
          b.vcx *= (1 - dragCoeff * dt);
          b.vcz *= (1 - dragCoeff * dt * 0.65);

          // Spin decay over time
          b.spin *= (1 - 0.5 * dt);

          // Move ball — with NaN guards
          b.cx += (b.vcx || 0) * dt; b.cz += (b.vcz || 0) * dt;
          if (isNaN(b.cx) || Math.abs(b.cx) > 10) b.cx = 0;
          if (isNaN(b.cz) || Math.abs(b.cz) > 10) b.cz = 0;

          // Ace detection timer
          if (this.aceTimer !== undefined) this.aceTimer += dt;

          // Bounce
          if (b.ch <= 0 && b.vch < 0) {
            b.ch = 0;
            // Spin-modified bounce: topspin = low fast kick, slice = higher slower pop
            const spinBounce = clamp(1 - b.spin * 0.35, 0.4, 1.8);
            b.vch = Math.abs(b.vch) * surf.bounce * spinBounce;
            // Add a small kick on bounce
            b.vcz *= (surf.friction + b.spin * 0.1);
            if (Math.abs(b.vch) < 0.1) b.vch = 0; // Hard stop
            sfxBounce(this.surface);
            this.bounced++;
            // Surface friction on bounce
            b.vcx *= surf.friction;

            // Surface-specific bounce particles
            const bounceSpeed = Math.abs(b.vch) * 30 + 15;
            if (this.surface === 'clay') {
              // Dust cloud rises
              Shake.add(1.5);
              Particles.emit(...this.bsp(), { count: 10, color: surf.particles, speed: bounceSpeed, life: 0.5, upward: 2, gravity: 40 });
            } else if (this.surface === 'grass') {
              // Low skid — grass blades
              Shake.add(0.8);
              Particles.emit(...this.bsp(), { count: 6, color: surf.particles, speed: bounceSpeed * 0.7, life: 0.3, upward: 0.5, gravity: 120 });
            } else {
              // Hard court — snappy sparks
              Shake.add(1.2);
              Particles.emit(...this.bsp(), { count: 8, color: surf.particles, speed: bounceSpeed * 0.9, life: 0.25, glow: true });
            }

            // Ace detection: serve bounced twice quickly on opponent's side
            if (this.bounced === 1 && this.lastHit === 'player' && b.cz < 0 && this.aceTimer < 2.5) {
              // First bounce landed — mark it, ace checks on double bounce
            }

            // Double bounce = point for other side (only if NOT serving toss)
            if (this.bounced >= 2 && !this.serving) {
              // Ace detection: if serve double-bounced very quickly
              const isAce = this.aceTimer < 3.0 && this.rally === 0 && this.lastHit === 'player' && b.cz < 0;
              if (isAce) {
                sfxAce(); Shake.add(8); freezeT = 0.2;
                Floats.add('ACE!', W / 2, H * 0.4, C.gold, 16);
                Particles.emit(W / 2, H * 0.45, { count: 30, color: [C.gold, '#fff', C.orange], speed: 100, life: 0.8, upward: 2, glow: true, spread: Math.PI * 2 });
              }
              if (this.lastHit === 'player' && b.cz < 0) {
                this.scorePoint('player');
              } else if (this.lastHit === 'opponent' && b.cz > 0) {
                this.scorePoint('opponent');
              } else if (this.lastHit === 'player' && b.cz > 0) {
                this.scorePoint('opponent');
              } else if (this.lastHit === 'opponent' && b.cz < 0) {
                this.scorePoint('player');
              }
            }
          }

          // Out of bounds sideways — ball is out
          if (Math.abs(b.cx) > 1.05 && this.bounced > 0) {
            Floats.add('OUT!', COURT.ballProj(b.cx, b.cz, b.ch).x, COURT.ballProj(b.cx, b.cz, b.ch).y - 15, C.red, 9);
            Shake.add(2);
            this.lastHit === 'player' ? this.scorePoint('opponent') : this.scorePoint('player');
          }

          // Net collision — wider zone so ball can't clip through
          if (Math.abs(b.cz) < 0.06 && b.ch < 0.18) {
            sfxNet(); Shake.add(4);
            this.netWobble = 1.0;
            const np = COURT.toScreen(0, 0);
            Particles.emit(np.x, np.y, { count: 14, color: ['#ddd', '#aaa', '#888'], speed: 50, life: 0.5, spread: Math.PI });
            Floats.add('NET!', np.x, np.y - 20, C.red, 10);
            // Ball drops dead at net
            b.vcz = 0; b.vcx *= 0.3; b.vch = 0.15;
            this.lastHit === 'player' ? this.scorePoint('opponent') : this.scorePoint('player');
          }

          // Ball goes past baseline — OUT
          if (b.cz > 1.08 && !this.pointScored) {
            Floats.add('OUT!', W / 2, H * 0.7, C.red, 10);
            Shake.add(2);
            this.lastHit === 'opponent' ? this.scorePoint('player') : this.scorePoint('opponent');
          }
          if (b.cz < -1.08 && !this.pointScored) {
            Floats.add('OUT!', W / 2, H * 0.3, C.red, 10);
            Shake.add(2);
            this.lastHit === 'player' ? this.scorePoint('opponent') : this.scorePoint('player');
          }

          const bp = COURT.ballProj(b.cx, b.cz, b.ch); Trail.add(bp.x, bp.y, bp.ps);
        }

        if (JP['Escape']) go(HubState);
      },

      draw() {
        Shake.apply();
        COURT.draw();
        // Court color based on surface
        const sc = this.surfStats[this.surface].color;
        px(W / 2 - 130, H * 0.2, 260, H * 0.7, sc + '44');
        px(W / 2 - 130, H * 0.2, 260, 2, C.white);
        px(W / 2 - 130, H * 0.89, 260, 2, C.white);

        if (this.hitFlash > 0) { ctx.fillStyle = `rgba(255,220,80,${this.hitFlash / 0.12 * 0.15})`; ctx.fillRect(0, 0, W, H); }
        Trail.draw();
        const b = this.ball;

        if (b.active || this.serving) {
          // Shadow
          const bs = COURT.toScreen(b.cx, b.cz);
          const ssz = Math.max(3, 12 * bs.ps * (1 - b.ch * 0.4));
          ctx.fillStyle = `rgba(0,0,0,${0.4 - b.ch * 0.1})`; ctx.beginPath(); ctx.ellipse(bs.x, bs.y, ssz, ssz * 0.4, 0, 0, Math.PI * 2); ctx.fill();
          // Ball with Squash & Stretch
          const bp = COURT.ballProj(b.cx, b.cz, b.ch);
          const bsz = Math.max(4, 9 * bp.ps);
          // Calculate stretch based on speed
          const speed = Math.sqrt(b.vcx * b.vcx + b.vcz * b.vcz + b.vch * b.vch);
          const stretch = Math.min(1.5, 1 + speed * 0.008);
          // Angle of movement
          const ang = Math.atan2(b.vcz, b.vcx);

          ctx.save();
          ctx.translate(bp.x, bp.y);
          if (speed > 10) ctx.rotate(ang); // Rotate to velocity
          ctx.scale(stretch, 1 / stretch); // Squash/Stretch
          ctx.shadowColor = '#c8ff40'; ctx.shadowBlur = bsz * 2;

          const drawSz = bsz * (1 / stretch); // Compensate size visual
          px(-drawSz / 2, -drawSz / 2, drawSz, drawSz, '#c8ff40');
          px(-drawSz / 2 + 1, -drawSz / 2 + 1, ~~(drawSz * 0.3), ~~(drawSz * 0.3), '#fff');
          ctx.restore();
        }

        // Opponent
        const op = COURT.toScreen(this.o.cx, this.o.cz);
        const osw = ~~(30 * op.ps), osh = ~~(42 * op.ps);
        drawSpr(this.o.anim, op.x - osw / 2, op.y - osh, osw, osh, true, 1, oppSpr);
        ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.beginPath(); ctx.ellipse(op.x, op.y, osw * 0.38, 3, 0, 0, Math.PI * 2); ctx.fill();
        // Player
        const pp = COURT.toScreen(this.p.cx, this.p.cz);
        const psw = ~~(46 * pp.ps), psh = ~~(58 * pp.ps);
        drawSpr(this.p.anim, pp.x - psw / 2, pp.y - psh, psw, psh, this.p.facing < 0);
        ctx.fillStyle = 'rgba(0,0,0,0.32)'; ctx.beginPath(); ctx.ellipse(pp.x, pp.y, psw * 0.36, 4, 0, 0, Math.PI * 2); ctx.fill();

        // Hit range ring — shows when ball is close enough to hit
        if (b.active && !this.pointScored && this.lastHit !== 'player') {
          const bd = Math.sqrt((b.cx - this.p.cx) ** 2 + (b.cz - this.p.cz) ** 2);
          if (bd < 0.45 && b.ch < 0.48) {
            const al = Math.max(0, (0.45 - bd) / 0.45);
            ctx.strokeStyle = `rgba(80,255,120,${al * 0.65})`; ctx.lineWidth = 2; ctx.setLineDash([3, 3]);
            ctx.beginPath(); ctx.arc(pp.x, pp.y - psh * 0.5, psw * 0.55, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]);
          }
        }
        Particles.draw(); Floats.draw();

        // Stamina bar
        const stc = this.p.stamina > 50 ? C.green : this.p.stamina > 25 ? C.gold : C.red;
        bar(W / 2 - 40, H - 10, 80, 6, this.p.stamina, 100, stc); txt('STA', W / 2 - 57, H - 5, C.dim, 6);

        // Charge glow/bar
        if (this.p.charge > 0.1) {
          const pp = COURT.toScreen(this.p.cx, this.p.cz);
          ctx.strokeStyle = this.p.charge > 0.9 ? C.gold : C.cyan; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(pp.x, pp.y - 30, 20 + this.p.charge * 10, 0, Math.PI * 2 * this.p.charge); ctx.stroke();
        }

        // Shot hints
        if (this.serving && this.server === 'player') {
          px(0, H - 30, W, 20, 'rgba(0,0,0,0.8)');
          txt('PRESS Z / X / SPACE TO SERVE', W / 2, H - 17, C.gold, 7, 'center');
        } else if (this.t < 12) {
          px(0, H - 28, W, 18, 'rgba(0,0,0,0.75)');
          txt('Z:TOPSPIN  ↑Z:LOB  ↓Z:DROP  X:SLICE  SPACE:FLAT', W / 2, H - 16, C.dim, 5, 'center');
        }

        // Match point msg
        if (this.ptMsgT > 0) {
          const ta = Math.min(1, this.ptMsgT * 2); ctx.globalAlpha = ta;
          px(W / 2 - 82, H * 0.42, 164, 24, 'rgba(0,0,0,0.85)');
          txt(this.ptMsg, W / 2, H * 0.42 + 16, this.ptMsg.includes('OPP') ? '#f05050' : C.gold, 9, 'center');
          ctx.globalAlpha = 1;
        }

        // Special Gauge sidebar
        const gx = 8, gy = 40, gw = 6, gh = 100;
        px(gx - 1, gy - 1, gw + 2, gh + 2, C.uiBd);
        px(gx, gy, gw, gh, 'rgba(0,0,0,0.5)');
        px(gx, gy + gh - (this.specialGauge / 100 * gh), gw, (this.specialGauge / 100 * gh), this.specialGauge >= 100 ? C.cyan : '#4080ff');
        if (this.specialGauge >= 100 && ~~(this.t * 8) % 2 === 0) {
          ctx.shadowColor = C.cyan; ctx.shadowBlur = 10;
          px(gx - 2, gy - 2, gw + 4, gh + 4, 'rgba(0,255,255,0.3)');
          ctx.shadowBlur = 0;
          txt('SPECIAL READY!', gx + 10, gy + gh / 2, C.cyan, 6, 'left');
        }
        txt('SP', gx + gw / 2, gy - 5, C.dim, 5, 'center');

        // Smash Star marker
        if (this.smashStar) {
          this.smashStar.t -= dt;
          if (this.smashStar.t <= 0) this.smashStar = null;
          else {
            const ss = COURT.toScreen(this.smashStar.cx, this.smashStar.cz);
            ctx.save();
            ctx.translate(ss.x, ss.y);
            ctx.rotate(this.t * 4);
            ctx.shadowColor = C.gold; ctx.shadowBlur = 15;
            ctx.strokeStyle = `rgba(240,180,40,${0.4 + Math.sin(this.t * 10) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const r = i % 2 === 0 ? 15 : 6;
              const a = (i / 5) * Math.PI * 2;
              ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            }
            ctx.closePath(); ctx.stroke();
            ctx.restore();
          }
        }

        // HUD — Score
        ctx.fillStyle = 'rgba(6,10,20,0.96)'; ctx.fillRect(0, 0, W, 28);
        ctx.fillStyle = C.uiBd; ctx.fillRect(0, 27, W, 1);

        // Tennis score display with premium text
        const scoreName = (pts, oppPts) => {
          if (pts < 4) return ['0', '15', '30', '40'][pts];
          if (pts === oppPts) return '40';
          if (pts > oppPts) return 'AD';
          return '40';
        };
        const pScore = scoreName(this.pPts, this.oPts);
        const oScore = scoreName(this.oPts, this.pPts);
        const isDeuce = this.pPts >= 3 && this.oPts >= 3 && this.pPts === this.oPts;

        // Player Score Side
        ctx.shadowColor = C.accent; ctx.shadowBlur = 4;
        txt(`YOU`, 12, 12, C.accent, 7, 'left');
        ctx.shadowBlur = 0;
        txt(pScore, 65, 12, C.white, 10, 'left');
        px(95, 4, 35, 18, 'rgba(255,255,255,0.05)');
        txt(`G:${this.pGames}`, 112, 12, C.gold, 7, 'center');

        // center info
        if (isDeuce) txt('DEUCE', W / 2, 12, C.gold, 8, 'center');
        else if (this.rally > 2) {
          ctx.fillStyle = 'rgba(0,255,255,0.1)'; ctx.fillRect(W / 2 - 30, 4, 60, 18);
          txt(`RALLY ${this.rally}`, W / 2, 12, this.rally > 8 ? C.gold : C.cyan, 7, 'center');
        } else txt('VS', W / 2, 12, C.dim, 7, 'center');

        // Opp Score Side
        px(W - 125, 4, 35, 18, 'rgba(255,255,255,0.05)');
        txt(`G:${this.oGames}`, W - 108, 12, '#f05050', 7, 'center');
        txt(oScore, W - 80, 12, C.white, 10, 'right');
        ctx.shadowColor = '#f05050'; ctx.shadowBlur = 4;
        txt(this.oppName, W - 12, 12, '#f05050', 7, 'right');
        ctx.shadowBlur = 0;

        // Server indicator
        const servDot = this.server === 'player' ? 52 : W - 56;
        ctx.fillStyle = C.gold; ctx.beginPath(); ctx.arc(servDot, 22, 3, 0, Math.PI * 2); ctx.fill();
        ctx.shadowColor = C.gold; ctx.shadowBlur = 8;
        px(servDot - 4, 25, 8, 2, C.gold);
        ctx.shadowBlur = 0;
        // Surface indicator
        const surfLabel = this.surfStats[this.surface].pName;
        const surfCol = this.surfStats[this.surface].color;
        px(W / 2 - 25, 20, 50, 10, surfCol + '44');
        txt(surfLabel, W / 2, 27, surfCol, 5, 'center');

        // Match point / Deuce warnings
        const pp2 = this.pPts, op2 = this.oPts;
        const isMatchPt = (this.pGames >= 5 && this.pGames - this.oGames >= 1 && pp2 >= 3 && pp2 > op2) ||
          (this.oGames >= 5 && this.oGames - this.pGames >= 1 && op2 >= 3 && op2 > pp2);
        if (isMatchPt && ~~(this.t * 3) % 2 === 0) {
          txt('MATCH POINT', W / 2, H * 0.35, C.gold, 10, 'center');
        }

        // Net wobble visual
        if (this.netWobble > 0) {
          this.netWobble -= 0.02;
          ctx.save(); ctx.translate(0, Math.sin(this.t * 30) * this.netWobble * 3); COURT.drawNet(); ctx.restore();
        }

        Shake.restore();

        // Intro overlay
        if (this.phase === 'intro') {
          const al = Math.max(0, 1 - this.introT * 0.8); ctx.fillStyle = `rgba(6,10,20,${al})`; ctx.fillRect(0, 0, W, H);
          if (this.introT < 2.5) {
            ctx.globalAlpha = Math.min(1, this.introT * 1.5);
            px(70, H / 2 - 55, W - 140, 96, 'rgba(0,0,0,0.88)'); px(70, H / 2 - 55, W - 140, 2, C.green);
            txt('VS ' + this.oppName, W / 2, H / 2 - 28, C.gold, 10, 'center');
            txt(`Opponent Level: ${this.oppLevel}`, W / 2, H / 2 - 6, C.white, 6, 'center');
            txt('First to 6 games (lead by 2)', W / 2, H / 2 + 10, C.dim, 6, 'center');
            txt('PRESS Z TO START', W / 2, H / 2 + 28, C.cyan, 7, 'center');
            ctx.globalAlpha = 1;
          }
        }
        // Results overlay
        if (this.phase === 'results') {
          ctx.fillStyle = 'rgba(6,10,20,0.88)'; ctx.fillRect(55, 55, W - 110, H - 110);
          const won = this.matchWinner === 'player'; px(55, 55, W - 110, 2, won ? C.gold : C.red);
          txt(won ? 'VICTORY!' : 'GAME OVER', W / 2, 90, won ? C.gold : C.red, 14, 'center');
          drawSpr(won ? 'fist' : 'dive', W / 2 - 22, 104, 44, 56);
          txt(`${this.pGames}    -    ${this.oGames}`, W / 2, 178, C.white, 16, 'center');
          txt('YOU         OPP', W / 2, 198, C.dim, 7, 'center');
          // HUD
          px(0, 0, W, 22, 'rgba(0,0,0,0.5)');
          txt(Stats.level > 1 ? `LVL ${Stats.level}` : 'ROOKIE', 10, 15, C.gold, 7);
          txt(`${this.pGames} - ${this.oGames}`, W / 2, 15, C.white, 9, 'center');
          txt('MATCH GAME', W / 2, 25, C.dim, 5, 'center');
          txt(`RALLY: ${this.rally}`, W - 10, 15, C.dim, 6, 'right');
          txt(`COURT: ${this.surface.toUpperCase()}`, 10, 30, this.surfStats[this.surface].color, 5);
          const xp = won ? 80 : 20;
          txt(`+${xp} XP  ·  +${Math.floor(xp * 1.5)}¢`, W / 2, 222, C.accent, 7, 'center');
          
          if (curMap === 1 && won) {
            const count = Math.min(3, Stats.gymChampionsDefeated + 1);
            const msg = count === 3 ? "GYM CLEARED!" : `CHAMPIONS DEFEATED: ${count}/3`;
            txt(msg, W / 2, 245, C.gold, 8, 'center');
          }

          if (~~(this.t * 2) % 2 === 0) txt('PRESS Z TO CONTINUE', W / 2, 275, C.gold, 8, 'center');
        }
      }
    };

    // ═══ HUB ════════════════════════════════════════════════
    const HubState = {
      t: 0, px2: W / 2, py: H * 0.6, anim: 'stand', animT: 0, frame: 0, facing: 1,
      activeNPC: null, dlgLine: 0,
      clouds: [], birds: [], leafTimer: 0,
      
      // Map Data
      mapData: [
        {
          name: "Academy",
          bg1: '#3a8adf', bg2: '#a8e0ff', ground: '#4a9a38',
          npcs: [
            { x: 80, y: 115, name: 'COACH NICK', color: '#4080ff', bobOff: 0, lines: ['Welcome to Baghdatis Academy!', 'I see potential in you, kid.', 'Train hard at the drills zone...', 'Or test yourself on the match court!', 'Remember: footwork is EVERYTHING.'] },
            { x: 256, y: 115, name: 'TRAINER ELENA', color: '#ff8040', bobOff: 1.5, lines: ['Drills build champions!', 'Split-step timing is crucial.', 'Focus on your topspin — it wins rallies.', 'Hit the Training Zone when ready!'] },
            { x: 420, y: 110, name: 'SHOP OWNER', color: '#c040ff', bobOff: 2.2, lines: ['Welcome to the Pro Shop!', 'New rackets boost your power.', 'Speed shoes improve court coverage.', 'Check what\'s in stock — press Z!'] },
            { x: 450, y: 300, name: 'BALL KID', color: '#40d080', bobOff: 3.1, lines: ['Hey! Did you know...', 'If you time your split-step perfectly,', 'you move WAY faster to the ball!', '...I wish I could play like you!'] },
            { x: 60, y: 310, name: 'RIVAL ALEX', color: '#f04060', bobOff: 0.7, lines: ['Don\'t get too comfortable here.', 'I\'ve been training every single day.', 'Next time we meet on court...', 'I won\'t go easy on you. Game on.'] }
          ],
          zones: [
            { x: 185, y: 125, w: 140, h: 65, label: 'TRAINING', color: '#ff804044', bg: '#ff804011', action: 'training', icon: '🎾' },
            { x: 10, y: 125, w: 110, h: 65, label: 'MATCH', color: '#4080ff44', bg: '#4080ff11', action: 'match', icon: '⚔' },
            { x: W - 138, y: 40, w: 134, h: 80, label: 'PRO SHOP', color: '#c040ff44', bg: '#c040ff11', action: 'shop', icon: '🛒' }
          ]
        },
        {
          name: "City Gym",
          bg1: '#0d1525', bg2: '#1a3a60', ground: '#333',
          npcs: [
            { 
              x: 256, y: 120, name: 'GYM BOSS', color: '#f03030', bobOff: 0, 
              get lines() {
                if (Stats.gymChampionsDefeated === 0) return ['So you think you can clear this gym?', 'You need to defeat my 3 champions first.', 'No rookie has ever done it.', 'Are you ready for the ultimate test?'];
                if (Stats.gymChampionsDefeated === 1) return ['One down, two to go.', 'The next champion won\'t be so easy.', 'Show me more of that spirit!'];
                if (Stats.gymChampionsDefeated === 2) return ['Impressive... only one remains.', 'The Grand Champion is waiting for you.', 'Don\'t let the pressure break you now.'];
                return ['You did it! You cleared the City Gym!', 'You are a true legend of the court.', 'The Academy is proud of you, kid.'];
              }
            },
            { x: 100, y: 300, name: 'ADVANCED TRAINER', color: '#00ffff', bobOff: 1.2, lines: ['The air is thinner here, kid.', 'Your stamina will be tested like never before.', 'Use the specialized machines...', 'Or get left behind in the dust.'] }
          ],
          zones: [
            { x: 180, y: 100, w: 155, h: 80, label: 'BOSS CHALLENGE', color: '#f0303044', bg: '#f0303011', action: 'boss', icon: '🔥' },
            { x: 50, y: 250, w: 120, h: 70, label: 'ADVANCED DRILLS', color: '#00ffff44', bg: '#00ffff11', action: 'training_adv', icon: '⚡' }
          ]
        }
      ],

      enter() {
        this.t = 0; this.activeNPC = null; this.dlgLine = 0;
        stopBGM(); // Ensure chiptune music stops
        // Safe spawn to avoid immediate re-triggering of bus
        if (curMap === 0) {
          this.px2 = W / 2; this.py = H * 0.65;
        } else {
          this.px2 = 100; this.py = H * 0.7;
        }
        // Spawn clouds
        this.clouds = [];
        for (let i = 0; i < 5; i++) this.clouds.push({ x: Math.random() * W, y: 10 + Math.random() * 50, w: 40 + Math.random() * 60, speed: 8 + Math.random() * 12 });
        // Spawn birds
        this.birds = [];
        for (let i = 0; i < 3; i++) this.birds.push({ x: Math.random() * W, y: 20 + Math.random() * 40, vx: 20 + Math.random() * 30, wingT: Math.random() * 6 });
        Particles.pool = [];
      },
      update(dt) {
        if (Transition.active) return;
        this.t += dt;
        const cur = this.mapData[curMap];
        // Animate clouds
        for (const c of this.clouds) { c.x += c.speed * dt; if (c.x > W + 60) c.x = -c.w - 10; }
        // Animate birds
        for (const b of this.birds) { b.x += b.vx * dt; b.wingT += dt * 8; if (b.x > W + 20) { b.x = -20; b.y = 15 + Math.random() * 45; } }
        // Ambient leaf/dust particles
        this.leafTimer += dt;
        if (this.leafTimer > 0.4) { this.leafTimer = 0; const col = curMap === 0 ? ['#90d060', '#c8e060', '#e8d870'] : ['#00ffff', '#444', '#888']; Particles.emit(Math.random() * W, H * 0.5 + Math.random() * H * 0.4, { count: 1, color: col, speed: 12, life: 2.5, size: 2, gravity: -8 }); }
        Particles.update(dt);

        if (this.activeNPC) {
          if (JP['Enter'] || JP['KeyZ']) {
            this.dlgLine++;
            if (this.dlgLine >= this.activeNPC.lines.length) { this.activeNPC = null; this.dlgLine = 0; sfxConfirm(); }
            else sfxMenu();
          }
          if (JP['Escape']) { this.activeNPC = null; sfxCancel(); }
          return;
        }
        const spd = 110; let dx = 0, dy = 0;
        if (Keys['ArrowLeft']) { dx = -1; this.facing = -1; } if (Keys['ArrowRight']) { dx = 1; this.facing = 1; }
        if (Keys['ArrowUp']) dy = -1; if (Keys['ArrowDown']) dy = 1;
        if (dx || dy) {
          const l = Math.sqrt(dx * dx + dy * dy); this.px2 += dx / l * spd * dt; this.py += dy / l * spd * dt;
          this.animT += dt; if (this.animT > 0.14) { this.frame = (this.frame + 1) % 2; this.animT = 0; }
          this.anim = this.frame === 0 ? 'run1' : 'run2';
        } else this.anim = 'stand';
        this.px2 = clamp(this.px2, 20, W - 20); this.py = clamp(this.py, 40, H - 40);
        
        // Zone entry
        for (const z of cur.zones) {
          const inZ = this.px2 > z.x && this.px2 < z.x + z.w && this.py > z.y && this.py < z.y + z.h;
          if (inZ && (JP['Enter'] || JP['KeyZ'])) {
            sfxConfirm();
            if (z.action === 'training' || z.action === 'training_adv') goTransition(TrainingSelectState);
            else if (z.action === 'match' || z.action === 'boss') goTransition(MatchState);
            else if (z.action === 'shop') goTransition(ShopState);
          }
        }

        // Bus Travel
        const busX = curMap === 0 ? 210 : 400; 
        const busY = curMap === 0 ? 320 : 300;
        const nearBus = Math.sqrt((this.px2 - (busX + 40)) ** 2 + (this.py - (busY + 16)) ** 2) < 55;
        if (nearBus && (JP['Enter'] || JP['KeyZ']) && !Transition.active) {
          sfxConfirm();
          const next = curMap === 0 ? 1 : 0;
          Transition.start(() => {
            curMap = next;
            go(LoadingScreenState);
          });
        }

        // NPC talk
        for (const n of cur.npcs) {
          if (JP['Enter'] || JP['KeyZ']) {
            if (Math.sqrt((this.px2 - n.x) ** 2 + (this.py - n.y) ** 2) < 42) {
              this.activeNPC = n; this.dlgLine = 0; sfxMenu(); break;
            }
          }
        }
        if (JP['Escape']) goTransition(HomeState);
      },
      // --- Drawing helpers ---
      drawBuilding(bx, by, bw, bh, wall, roof, roofH, label, windowCount, doorColor) {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(bx + 4, by + 4, bw, bh);
        // Walls
        px(bx, by, bw, bh, wall);
        // Brick texture
        for (let r = 0; r < ~~(bh / 8); r++) {
          for (let c = 0; c < ~~(bw / 16); c++) {
            const ox = (r % 2) * 8;
            ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.lineWidth = 1;
            ctx.strokeRect(bx + c * 16 + ox, by + r * 8, 16, 8);
          }
        }
        // Roof — triangular accent
        px(bx - 2, by - roofH, bw + 4, roofH + 2, roof);
        px(bx - 2, by - roofH, bw + 4, 2, '#ffffff44');
        // Roof tiles pattern
        for (let ri = 0; ri < ~~(bw / 10); ri++) px(bx + ri * 10, by - roofH + 3, 9, 3, 'rgba(0,0,0,0.1)');
        // Windows with warm glow
        const winW = 12, winH = 10;
        for (let wi = 0; wi < windowCount; wi++) {
          const wx = bx + 8 + wi * ~~((bw - 16) / Math.max(1, windowCount - 1));
          const wy = by + 10;
          px(wx, wy, winW, winH, '#1a2040');
          // Window glow
          const glowA = 0.3 + Math.sin(this.t * 1.5 + wi * 1.2) * 0.15;
          px(wx + 1, wy + 1, winW - 2, winH - 2, `rgba(255,220,120,${glowA})`);
          px(wx + winW / 2, wy, 1, winH, '#ffffff55'); // crossbar
          px(wx, wy + winH / 2, winW, 1, '#ffffff55');
          // Frame
          ctx.strokeStyle = '#a08060'; ctx.lineWidth = 1; ctx.strokeRect(wx, wy, winW, winH);
        }
        // Door
        const dw = 10, dh = 16;
        px(bx + bw / 2 - dw / 2, by + bh - dh, dw, dh, doorColor || '#6a4020');
        px(bx + bw / 2 + 2, by + bh - dh / 2, 2, 2, '#f0c040'); // doorknob
        // Sign
        const sw = label.length * 5 + 8;
        px(bx + bw / 2 - sw / 2, by - roofH - 10, sw, 9, 'rgba(0,0,0,0.85)');
        txt(label, bx + bw / 2, by - roofH - 3, C.gold, 5, 'center');
      },
      drawTree(tx, ty, swayAmount) {
        const sway = Math.sin(this.t * 1.8 + tx * 0.1) * swayAmount;
        // Trunk
        px(tx - 3, ty, 6, 16, '#6b4020'); px(tx - 2, ty + 2, 2, 12, '#8b5030');
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(tx, ty + 18, 10, 4, 0, 0, Math.PI * 2); ctx.fill();
        // Canopy layers (swaying)
        [[-8, -10, 16, 12, '#2a8a3a'], [-10, -16, 20, 12, '#3aaa4a'], [-6, -20, 12, 8, '#4ac05a']].forEach(([ox, oy, ow, oh, col]) => {
          px(tx + ox + sway, ty + oy, ow, oh, col);
        });
        // Leaf shimmer
        if (Math.random() < 0.02) Particles.emit(tx + sway, ty - 14, { count: 1, color: ['#90e060'], speed: 8, life: 1.5, size: 1.5, gravity: 15 });
      },
      drawFountain(fx, fy) {
        // Base
        px(fx - 14, fy, 28, 8, '#8888aa'); px(fx - 12, fy + 2, 24, 4, '#9999bb');
        // Bowl
        px(fx - 10, fy - 6, 20, 8, '#7777aa'); px(fx - 4, fy - 12, 8, 8, '#8888bb');
        // Water sparkle
        const sp = Math.sin(this.t * 5);
        const sp2 = Math.sin(this.t * 7 + 1);
        ctx.save(); ctx.globalAlpha = 0.5 + sp * 0.3;
        px(fx - 2 + sp * 3, fy - 16 - Math.abs(sp) * 6, 3, 3, '#60c0ff');
        px(fx + 1 + sp2 * 2, fy - 14 - Math.abs(sp2) * 4, 2, 2, '#80d0ff');
        ctx.restore();
        // Water drops particles
        if (Math.random() < 0.08) Particles.emit(fx, fy - 14, { count: 1, color: ['#60c0ff', '#a0e0ff'], speed: 15, life: 0.8, size: 1.5, gravity: 50, upward: 2 });
      },
      draw() {
        const cur = this.mapData[curMap];
        // === SKY with gradient ===
        const skyGrad = ctx.createLinearGradient(0, 0, 0, 95);
        skyGrad.addColorStop(0, cur.bg1); skyGrad.addColorStop(1, cur.bg2);
        ctx.fillStyle = skyGrad; ctx.fillRect(0, 0, W, 95);
        
        if (curMap === 0) {
          // Sun
          ctx.save(); ctx.globalAlpha = 0.25; ctx.fillStyle = '#ffe860';
          ctx.beginPath(); ctx.arc(W - 60, 30, 22, 0, Math.PI * 2); ctx.fill();
          ctx.globalAlpha = 0.08; ctx.beginPath(); ctx.arc(W - 60, 30, 40, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        } else {
          // Moon / Night
          ctx.save(); ctx.globalAlpha = 0.4; ctx.fillStyle = '#fff';
          ctx.beginPath(); ctx.arc(W - 60, 30, 18, 0, Math.PI * 2); ctx.fill();
          ctx.globalAlpha = 0.1; ctx.beginPath(); ctx.arc(W - 60, 30, 30, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        }

        // Clouds
        for (const c of this.clouds) {
          ctx.fillStyle = curMap === 0 ? 'rgba(255,255,255,0.45)' : 'rgba(100,120,255,0.15)';
          ctx.beginPath(); ctx.ellipse(c.x, c.y, c.w * 0.5, 8, 0, 0, Math.PI * 2); ctx.fill();
        }
        // Birds
        for (const b of this.birds) {
          const wing = Math.sin(b.wingT) * 3;
          ctx.strokeStyle = curMap === 0 ? 'rgba(40,40,40,0.5)' : 'rgba(200,200,255,0.3)'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(b.x - 4, b.y + wing); ctx.lineTo(b.x, b.y); ctx.lineTo(b.x + 4, b.y + wing); ctx.stroke();
        }

        // === GROUND ===
        ctx.fillStyle = cur.ground; ctx.fillRect(0, 90, W, H - 90);
        
        if (curMap === 0) {
          // Map 1 specific drawing
          // Grass color bands
          for (let gi = 0; gi < 8; gi++) {
            ctx.fillStyle = gi % 2 === 0 ? 'rgba(0,0,0,0.03)' : 'rgba(255,255,255,0.02)';
            ctx.fillRect(0, 95 + gi * 36, W, 36);
          }
          // Dirt paths
          px(0, 218, W, 20, C.sand); px(0, 236, W, 4, C.sandD);
          px(168, 95, 22, H - 95, C.sandD); px(188, 95, 2, H - 95, C.sand);
          
          // Mini Courts
          [[42, 138, 118, 60, '#2a8c4a'], [368, 138, 108, 60, '#2a8c4a']].forEach(([cx, cy, cw, ch, col]) => {
            px(cx, cy, cw, ch, col);
            ctx.strokeStyle = '#ffffff55'; ctx.lineWidth = 1; ctx.strokeRect(cx + 4, cy + 4, cw - 8, ch - 8);
            px(cx + 4, cy + ch / 2 - 1, cw - 8, 2, '#e0e0e0cc');
          });
          
          this.drawBuilding(2, 48, 125, 48, '#e8d8c0', '#c83828', 10, 'ACADEMY HQ', 4, '#5a3018');
          this.drawBuilding(W - 138, 48, 134, 48, '#d0e0f8', '#2060a8', 10, 'PRO SHOP', 4, '#2850a0');
          this.drawBuilding(178, 55, 155, 40, '#e8d0b0', '#d06020', 8, 'GYM / TRAINING', 5, '#6a4020');
          
          this.drawTree(20, 115, 2.5); this.drawTree(145, 110, 2); this.drawTree(340, 108, 3);
          this.drawFountain(256, 260);
        } else {
          // Map 2 specific drawing (City Gym)
          // Concrete grid
          ctx.strokeStyle = 'rgba(255,255,255,0.05)';
          for(let i=0; i<W; i+=40) { ctx.beginPath(); ctx.moveTo(i, 90); ctx.lineTo(i, H); ctx.stroke(); }
          
          // Neon Buildings
          this.drawBuilding(180, 60, 155, 80, '#1a1a2a', '#f03030', 5, 'CITY ELITE GYM', 6, '#301010');
          this.drawBuilding(20, 220, 100, 60, '#101020', '#00ffff', 5, 'TEK SHOP', 3, '#004444');
          
          // Champions Wall
          px(W - 120, 100, 100, 60, 'rgba(0,0,0,0.6)');
          px(W - 120, 100, 100, 2, C.gold);
          txt('CHAMPIONS', W - 70, 115, C.gold, 5, 'center');
          for(let i=0; i<3; i++) {
            const won = Stats.gymChampionsDefeated > i;
            px(W - 110 + i * 30, 125, 20, 20, won ? C.gold : '#222');
            if (won) txt('★', W - 100 + i * 30, 140, C.dark, 8, 'center');
          }

          // Street Lights
          [50, 460].forEach(lx => {
            px(lx-2, 100, 4, H-100, '#222');
            ctx.save(); ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 15;
            px(lx-6, 100, 12, 6, '#00ffff'); ctx.restore();
          });
        }

        // === BUS / COACH ===
        const busX = curMap === 0 ? 210 : 400; 
        const busY = curMap === 0 ? 320 : 300;
        // Body
        px(busX, busY, 80, 32, '#2060c0'); px(busX, busY, 80, 4, '#3080e0'); px(busX, busY + 28, 80, 4, '#1a4a90');
        // Windows
        for (let wi = 0; wi < 5; wi++) px(busX + 6 + wi * 15, busY + 6, 11, 10, '#a0d8ff');
        px(busX + 14, busY + 20, 52, 9, 'rgba(0,0,0,0.7)');
        txt(curMap === 0 ? 'TO CITY' : 'TO ACADEMY', busX + 40, busY + 27, C.gold, 5, 'center');
        
        const nearBus = Math.sqrt((this.px2 - (busX + 40)) ** 2 + (this.py - (busY + 16)) ** 2) < 55;
        if (nearBus) {
          px(busX + 10, busY - 18, 60, 14, 'rgba(0,0,0,0.88)');
          txt('[Z] TRAVEL', busX + 40, busY - 8, C.gold, 5, 'center');
        }

        // === ZONES ===
        for (const z of cur.zones) {
          px(z.x, z.y, z.w, z.h, z.bg);
          ctx.strokeStyle = z.color.replace('44', '66'); ctx.lineWidth = 1;
          ctx.strokeRect(z.x, z.y, z.w, z.h);
          const near = Math.sqrt((this.px2 - (z.x + z.w / 2)) ** 2 + (this.py - (z.y + z.h / 2)) ** 2) < 80;
          if (near) {
            px(z.x, z.y - 19, z.w, 16, 'rgba(0,0,0,0.88)');
            txt('[Z] ' + z.label, z.x + z.w / 2, z.y - 7, C.accent, 6, 'center');
          }
        }

        // === NPCs ===
        for (const n of cur.npcs) {
          const breathe = Math.sin(this.t * 2.5 + n.bobOff) * 1.5;
          const nSpr = (n.name.includes('TRAINER') || n.name.includes('RIVAL') || n.name.includes('BOSS')) ? oppSpr : null;
          drawSpr('stand', n.x - 14, n.y - 32 + breathe, 28, 38, n.name.includes('RIVAL'), 1, nSpr);
          if (Math.sqrt((this.px2 - n.x) ** 2 + (this.py - n.y) ** 2) < 48) {
            txt(n.name, n.x, n.y - 38, n.color, 5, 'center');
          }
        }

        // === PLAYER ===
        drawSpr(this.anim, this.px2 - 15, this.py - 24, 30, 42, this.facing < 0);
        
        Particles.draw();

        // Dialogue
        if (this.activeNPC) {
          const n = this.activeNPC;
          ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(0, 0, W, H);
          const dbY = H - 85;
          ctx.fillStyle = 'rgba(10,15,35,0.98)'; ctx.fillRect(16, dbY, W - 32, 72);
          px(16, dbY, W - 32, 2, n.color);
          txt(n.name, 68, dbY + 16, n.color, 7);
          txt(n.lines[this.dlgLine], 68, dbY + 36, C.white, 7);
        }
        drawGlobalHUD();
      }
    };

    // ═══ GLOBAL HUD ═══════════════════════════════════════════
    function drawGlobalHUD() {
      px(0, 0, W, 18, 'rgba(6,10,20,0.95)'); px(0, 17, W, 1, C.uiBd + '66');
      [['PWR', Stats.power, C.red], ['AGI', Stats.agility, C.cyan], ['STA', Stats.stamina, C.green], ['TCH', Stats.touch, C.purple], ['SRV', Stats.serve, C.gold]].forEach((s, i) => { bar(5 + i * 100 + 22, 4, 65, 8, s[1], 99, s[2], '#1a1a2a'); txt(s[0], 5 + i * 100, 12, s[2], 6); });
      txt(`LV${Stats.level}`, W - 32, 12, C.accent, 7);
    }

    // ═══ TRAINING SELECT ════════════════════════════════════
    const TrainingSelectState = {
      t: 0, sel: 0,
      get drills() {
        if (curMap === 0) {
          return [
            { name: 'SPLIT-STEP SPRINT', stat: 'agility', color: C.cyan, desc: 'TIME your hop for explosive reach', thumb: 'split' },
            { name: 'BORROW THE PACE', stat: 'stamina', color: C.orange, desc: 'QUICK-TAP to block 130mph serves', thumb: 'pace' },
            { name: 'TOPSPIN SMASH', stat: 'power', color: C.red, desc: 'HIT the rhythm zone for heavy spin', thumb: 'smash' },
            { name: 'SERVICE TOWER', stat: 'serve', color: C.gold, desc: 'BALANCE the toss for ACE serves', thumb: 'toss' },
            { name: 'FIGHTING SPIRIT', stat: 'stamina', color: C.purple, desc: 'BREATHE through the fist pump', thumb: 'spirit' }
          ];
        } else {
          return [
            { name: 'NEON SPRINT', stat: 'agility', color: '#00ffff', desc: 'ADVANCED movement in high-G city air', thumb: 'split' },
            { name: 'CYBER BLOCK', stat: 'stamina', color: '#ff00ff', desc: 'BLOCK hypersonic automated serves', thumb: 'pace' },
            { name: 'GRAVITY SMASH', stat: 'power', color: '#ff3333', desc: 'CRUSH targets with extreme topspin', thumb: 'smash' },
            { name: 'TECH TOSS', stat: 'serve', color: '#ffff00', desc: 'PRECISION electronic serve calibration', thumb: 'toss' },
            { name: 'IRON WILL', stat: 'stamina', color: '#00ff00', desc: 'ULTIMATE mental focus under pressure', thumb: 'spirit' }
          ];
        }
      },
      enter() { this.t = 0; this.sel = 0; },
      update(dt) {
        this.t += dt;
        const count = this.drills.length;
        if (JP['ArrowUp']) { this.sel = (this.sel - 1 + count) % count; sfxMenu(); }
        if (JP['ArrowDown']) { this.sel = (this.sel + 1) % count; sfxMenu(); }
        if (JP['Enter'] || JP['KeyZ']) { sfxWin();[Minigame_SplitStep, Minigame_BorrowPace, Minigame_TopspinSmash, Minigame_ServiceToss, Minigame_FightingSpirit][this.sel].enter && go([Minigame_SplitStep, Minigame_BorrowPace, Minigame_TopspinSmash, Minigame_ServiceToss, Minigame_FightingSpirit][this.sel]); }
        if (JP['Escape']) go(HubState);
      },
      draw() {
        const bg = ctx.createLinearGradient(0, 0, 0, H); bg.addColorStop(0, '#0a1020'); bg.addColorStop(1, '#060c18'); ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);
        px(0, 0, W, 30, 'rgba(0,0,0,0.6)'); px(0, 29, W, 1, C.uiBd); txt('TRAINING ZONE', W / 2, 19, C.gold, 10, 'center'); txt('SELECT A DRILL', W / 2, H - 7, C.dim, 6, 'center');
        this.drills.forEach((d, i) => {
          const y = 38 + i * 66, sel = i === this.sel;
          px(30, y, W - 60, 60, sel ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.5)'); px(30, y, 4, 60, d.color);
          
          // Draw Thumbnail
          const img = thumbs[d.thumb];
          if (img && img.complete) {
            ctx.drawImage(img, 38, y + 6, 80, 48);
            ctx.strokeStyle = sel ? d.color : 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 2;
            ctx.strokeRect(38, y + 6, 80, 48);
          } else {
            px(38, y + 6, 80, 48, '#1a1a2a');
          }

          if (sel) { px(30, y, W - 60, 1, d.color + 'aa'); px(30, y + 59, W - 60, 1, d.color + '44'); }
          txt(d.name, 128, y + 18, sel ? C.accent : C.white, 8); txt(d.desc, 128, y + 36, C.dim, 6);
          const sv = Stats[d.stat]; px(W - 85, y + 12, 52, 36, d.color + '22'); px(W - 85, y + 12, 52, 1, d.color + '66');
          txt(d.stat.slice(0, 3).toUpperCase(), W - 59, y + 26, d.color, 6, 'center'); bar(W - 83, y + 32, 48, 6, sv, 99, d.color, '#1a1a2a');
          if (sel) txt('▶', W - 22, y + 30, C.gold, 8);
        });
        drawGlobalHUD(); txt('ESC: BACK', 5, H - 4, C.dim, 6);
      }
    };

    // ═══ MINIGAME HELPERS ═══════════════════════════════════
    function mgBg(c1 = '#1a1a2e', c2 = '#0a0a18') { const g = ctx.createLinearGradient(0, 0, 0, H); g.addColorStop(0, c1); g.addColorStop(1, c2); ctx.fillStyle = g; ctx.fillRect(0, 0, W, H); }
    function mgHUD(label, color, ex1 = '', ex2 = '') { px(0, 0, W, 20, 'rgba(6,10,20,0.95)'); px(0, 19, W, 1, color + '66'); txt(label, 5, 13, color, 7); if (ex1) txt(ex1, 175, 13, C.gold, 7); if (ex2) txt(ex2, W - 8, 13, C.dim, 7, 'right'); }
    function mgIntro(label, color, ...lines) { ctx.fillStyle = 'rgba(6,10,20,0.9)'; ctx.fillRect(50, 55, W - 100, 222); px(50, 55, W - 100, 2, color); txt(label, W / 2, 80, color, 10, 'center'); lines.forEach((l, i) => { if (l) txt(l, W / 2, 110 + i * 20, i >= lines.length - 2 ? color : C.white, 7, 'center'); }); }
    function mgResults(t, label, color, score, xp, stat, extra = '') {
      ctx.fillStyle = 'rgba(6,10,20,0.92)'; ctx.fillRect(60, 70, W - 120, 230); px(60, 70, W - 120, 2, color);
      txt('DRILL COMPLETE!', W / 2, 100, C.gold, 12, 'center'); drawSpr('fist', W / 2 - 18, 108, 36, 46);
      txt(label + ': ' + score, W / 2, 168, C.white, 9, 'center');
      if (extra) txt(extra, W / 2, 188, C.cyan, 7, 'center');
      txt(`+${xp} ${stat.toUpperCase()} XP  ·  +${Math.floor(xp * 1.5)}¢`, W / 2, 212, C.accent, 9, 'center');
      if (~~(t * 2) % 2 === 0) txt('PRESS Z TO CONTINUE', W / 2, 255, C.gold, 7, 'center');
    }

    // ═══ MG1: SPLIT-STEP SPRINT ═════════════════════════════
    const Minigame_SplitStep = {
      t: 0, phase: 'intro', introT: 0, balls: [], fireT: 0, fireRate: 2.8,
      px2: W / 2, score: 0, combo: 0, maxCombo: 0, lives: 4, dives: 0,
      splitWindow: false, splitGrace: 0, splitReady: false, flash: 0, msg: '', msgT: 0,
      diving: false, diveT: 0,
      // 5 target zones across the court
      targets: [25, W * 0.25, W / 2, W * 0.75, W - 25],
      enter() {
        Object.assign(this, {
          t: 0, phase: 'intro', introT: 0, balls: [], fireT: 0, fireRate: 2.8,
          px2: W / 2, score: 0, combo: 0, maxCombo: 0, lives: 4, dives: 0,
          splitWindow: false, splitGrace: 0, splitReady: false, flash: 0,
          msg: '', msgT: 0, diving: false, diveT: 0
        });
        Particles.pool = []; Floats.pool = [];
      },
      update(dt) {
        this.t += dt; if (this.msgT > 0) this.msgT -= dt; if (this.flash > 0) this.flash -= dt;
        Shake.update(dt); Particles.update(dt); Floats.update(dt);
        if (this.diving) { this.diveT -= dt; if (this.diveT <= 0) this.diving = false; }
        if (this.phase === 'intro') { this.introT += dt; if (this.introT > 2 || JP['Enter'] || JP['KeyZ']) this.phase = 'play'; return; }
        if (this.phase === 'results') { if (JP['Enter'] || JP['KeyZ']) { Stats.addXP(this.score * 5 + this.dives * 8, 'agility'); sfxWin(); go(TrainingSelectState); } return; }

        // Fire balls to random target zones — adjusted fireRate for longer flight
        this.fireT += dt; this.fireRate = Math.max(2.4, 3.6 - this.score * 0.02);
        if (this.fireT >= this.fireRate) {
          this.fireT = 0;
          // Pick a target zone — avoid the one closest to player
          let zone;
          const playerZone = this.targets.reduce((best, t, i) => Math.abs(t - this.px2) < Math.abs(this.targets[best] - this.px2) ? i : best, 0);
          do { zone = ~~(Math.random() * 5); } while (zone === playerZone && Math.random() > 0.2);
          const tx = this.targets[zone];
          // ty is now deeper, dur is longer (2.4s)
          this.balls.push({ x: W / 2, y: H * 0.25, tx, ty: H * 0.82, t: 0, dur: 2.4, done: false, missed: false, zone, bounced: false });
          this.splitWindow = true; this.splitGrace = 0.5; this.flash = 0.15;
          tone(900, 'sine', 0.04, 0.12); Shake.add(1);
        }

        // Split-step window
        if (this.splitWindow) { this.splitGrace -= dt; if (this.splitGrace <= 0) { this.splitWindow = false; this.splitReady = false; } }
        if ((JP['KeyZ'] || JP['Space'] || JP['KeyX']) && this.splitWindow && !this.diving) { this.splitReady = true; tone(660, 'square', 0.04, 0.15); }

        // Player movement
        const sp = this.splitReady ? 420 : 180;
        if (!this.diving) {
          if (Keys['ArrowLeft']) this.px2 = Math.max(10, this.px2 - sp * dt);
          if (Keys['ArrowRight']) this.px2 = Math.min(W - 10, this.px2 + sp * dt);
        }

        // Ball movement & collision
        for (const b of this.balls) {
          if (b.done || b.missed) continue;
          b.t += dt;
          const p = Math.min(1.2, b.t / b.dur); // Allow a bit over 1.0 for bounce window

          b.cx = b.x + (b.tx - b.x) * Math.min(1, p);
          // Visual bounce physics
          if (p <= 1.0) {
            b.cy = b.y + (b.ty - b.y) * p + Math.sin(p * Math.PI) * -50;
          } else {
            // Bounce up slightly after 1.0
            const bp = p - 1.0;
            b.cy = b.ty + Math.sin(bp * 5) * -15;
            if (!b.bounced) { b.bounced = true; sfxBounce('hard'); }
          }

          // Diving hit — triggers on Direction + Action (or just KeyX)
          const dirHit = (Keys['ArrowLeft'] || Keys['ArrowRight']) && (JP['KeyZ'] || JP['Space'] || JP['KeyX']);
          if (!b.done && p > 0.7 && p < 1.15 && !this.diving) {
            const diveRange = 75;
            if ((JP['KeyX'] || dirHit) && Math.abs(this.px2 - b.cx) < diveRange && Math.abs(this.px2 - b.cx) > 30) {
              this.diving = true; this.diveT = 0.6;
              // Lunge toward ball
              this.px2 = lerp(this.px2, b.tx, 0.75); // Lunge further
              b.done = true; this.score += 2; this.combo++; this.dives++;
              this.maxCombo = Math.max(this.maxCombo, this.combo);
              this.msg = 'DIVING HIT!'; this.msgT = 1.0;
              sfxTopspin(); Shake.add(5); freezeT = 0.08;
              Particles.emit(b.cx, b.cy, { count: 15, color: [C.gold, '#fff'], speed: 70, life: 0.5, upward: 1.5, glow: true });
              Floats.add('DIVE!', b.cx, b.cy - 30, C.gold, 12);
              continue;
            }
          }

          // Normal reach check
          if (!b.done && p >= 1.0) {
            const catchZone = this.splitReady ? 50 : 38;
            if (Math.abs(this.px2 - b.tx) < catchZone) {
              b.done = true; this.score++; this.combo++; this.maxCombo = Math.max(this.maxCombo, this.combo);
              this.msg = this.splitReady ? 'SPLIT-STEP!' : 'NICE REACH!'; this.msgT = 0.8;
              sfxHit(); Shake.add(this.splitReady ? 3 : 1);
              Particles.emit(b.cx, b.cy, { count: 10, color: [C.cyan, '#c8ff40', '#fff'], speed: 50, life: 0.4, upward: 1, glow: true });
              Floats.add(this.splitReady ? 'SPLIT!' : 'REACH!', b.cx, b.cy - 20, this.splitReady ? C.gold : C.white, 9);
              this.splitReady = false; this.splitWindow = false;
            } else if (p >= 1.15) {
              b.missed = true; this.lives--; this.combo = 0;
              this.msg = 'MISSED!'; this.msgT = 0.8;
              sfxLose(); Shake.add(4);
              Particles.emit(b.cx, b.cy, { count: 8, color: ['#ff4040', '#ff8080'], speed: 40, life: 0.4 });
              if (this.lives <= 0) { this.phase = 'results'; sfxFistPump(); }
            }
          }
        }
        this.balls = this.balls.filter(b => b.t < b.dur * 1.5);
        if (JP['Escape']) go(TrainingSelectState);
      },
      draw() {
        Shake.apply(); mgBg('#0d1a30', '#060c18');
        // Court surface — slightly deeper
        px(0, H * 0.52, W, H * 0.48, C.court); px(0, H * 0.52, W, 2, '#ffffff33'); px(10, H * 0.72, W - 20, 1, '#ffffff44');

        // Draw all 5 target zones — moved further down (H * 0.82)
        const zoneColors = ['#ff4040', '#ff8040', '#40c0ff', '#ff8040', '#ff4040'];
        const zoneLabels = ['FAR', 'MID', 'CTR', 'MID', 'FAR'];
        this.targets.forEach((tx, i) => {
          const zw = 58, zh = 24, zy = H * 0.82; // Increased size and depth
          px(tx - zw / 2, zy, zw, zh, zoneColors[i] + '22');
          px(tx - zw / 2, zy, zw, 1, zoneColors[i] + '66');
          txt(zoneLabels[i], tx, zy + 16, zoneColors[i] + 'aa', 5, 'center');
        });

        // Ball machine
        px(W / 2 - 22, H * 0.22, 44, 22, '#4080c0'); px(W / 2 - 9, H * 0.19, 18, 8, '#80c0ff');
        if (this.flash > 0) { ctx.save(); ctx.shadowColor = '#ffff40'; ctx.shadowBlur = 22; px(W / 2 - 5, H * 0.16, 10, 8, '#ffff40'); ctx.restore(); }

        // Balls in flight
        for (const b of this.balls) {
          if (!b.cx || b.done) continue;
          ctx.save(); ctx.shadowColor = '#c8ff40'; ctx.shadowBlur = 8;
          px(b.cx - 5, b.cy - 5, 10, 10, '#c8ff40'); px(b.cx - 4, b.cy - 4, 3, 3, '#fff');
          ctx.restore();
          // Landing indicator
          const p = b.t / b.dur;
          if (p > 0.4) {
            const al = (p - 0.4) * 1.6;
            ctx.globalAlpha = Math.min(0.4, al);
            ctx.strokeStyle = '#c8ff40'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
            ctx.beginPath(); ctx.ellipse(b.tx, b.ty + 4, 18, 6, 0, 0, Math.PI * 2); ctx.stroke();
            ctx.setLineDash([]); ctx.globalAlpha = 1;
          }
        }

        // Split-step flash
        if (this.splitWindow) { const al = this.splitGrace / 0.5 * 0.25; ctx.fillStyle = `rgba(255,200,40,${al})`; ctx.fillRect(0, 0, W, H); txt('SPLIT-STEP! [Z/X/SPACE]', W / 2, H * 0.45, C.gold, 10, 'center'); }

        // Player character — action-matched animation
        let playerFrame;
        if (this.diving) playerFrame = 'dive';
        else if (this.splitReady && (Keys['ArrowLeft'] || Keys['ArrowRight'])) {
          playerFrame = this.t % 0.3 < 0.15 ? 'run1' : 'run2'; // Running animation cycle
        } else if (this.splitReady) playerFrame = 'splitStep';
        else if (Keys['ArrowLeft'] || Keys['ArrowRight']) {
          playerFrame = this.t % 0.3 < 0.15 ? 'run1' : 'run2';
        } else playerFrame = 'ready';
        // Check if just hit a ball — show forehand/backhand briefly
        for (const b of this.balls) {
          if (b.done && !b.missed && b.t < b.dur + 0.25) {
            playerFrame = Math.abs(this.px2 - b.cx) > 0 && this.px2 < b.cx ? 'forehand' : 'backhand';
          }
        }
        drawSpr(playerFrame, this.px2 - 14, H * 0.82 + 5 - 33, 28, 38);
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(this.px2, H * 0.82 + 5 + 6, 12, 4, 0, 0, Math.PI * 2); ctx.fill();

        // Speed rings when split-step ready
        if (this.splitReady) { ctx.strokeStyle = '#40ff80'; ctx.lineWidth = 2; for (let i = 1; i <= 3; i++) { ctx.globalAlpha = 0.5 - i * 0.14; ctx.beginPath(); ctx.arc(this.px2, H * 0.82 + 5 - 16, 18 + i * 7, 0, Math.PI * 2); ctx.stroke(); } ctx.globalAlpha = 1; }

        // Dive prompt — show when ball is in dive range
        if (!this.diving) {
          for (const b of this.balls) {
            if (b.done || b.missed || !b.cx) continue;
            const p = b.t / b.dur;
            if (p > 0.6 && p < 0.95 && Math.abs(this.px2 - b.cx) < 65) {
              ctx.globalAlpha = 0.7 + Math.sin(this.t * 12) * 0.3;
              txt('[X] DIVE!', b.cx, b.cy - 18, C.orange, 6, 'center');
              ctx.globalAlpha = 1;
            }
          }
        }

        if (this.msgT > 0) { ctx.globalAlpha = Math.min(1, this.msgT * 2); txt(this.msg, W / 2, H * 0.5, C.gold, 10, 'center'); ctx.globalAlpha = 1; }
        Particles.draw(); Floats.draw();
        for (let i = 0; i < 4; i++) px(W - 38 + i * 10 - 5, 22, 8, 8, i < this.lives ? C.red : '#333');
        mgHUD('SPLIT-STEP SPRINT', C.cyan, `SCORE:${this.score}  COMBO:${this.combo}x  DIVES:${this.dives}`);
        if (this.phase === 'intro') mgIntro('SPLIT-STEP SPRINT', C.cyan, 'When machine FLASHES, tap [Z]', 'for a Split-Step speed burst!', 'Sprint with ARROWS to the ball.', 'Press [X] near ball to DIVE!', 'Dives = +2 points!', 'PRESS Z TO START');
        if (this.phase === 'results') mgResults(this.t, 'Score', C.cyan, this.score, this.score * 5 + this.dives * 8, 'agility', `Dives: ${this.dives}  Best combo: ${this.maxCombo}x`);
        Shake.restore();
      }
    };

    // ═══ MG2: BORROW THE PACE ═══════════════════════════════
    const Minigame_BorrowPace = {
      t: 0, phase: 'intro', introT: 0, py2: H * 0.5, balls: [], ballT: 0, nextBall: 1.5,
      score: 0, lives: 5, holding: false, holdT: 0, prevH: false, msg: '', msgT: 0,
      enter() { Object.assign(this, { t: 0, phase: 'intro', introT: 0, py2: H * 0.5, balls: [], ballT: 0, nextBall: 1.5, score: 0, lives: 5, holding: false, holdT: 0, prevH: false, msg: '', msgT: 0 }); Particles.pool = []; Floats.pool = []; },
      update(dt) {
        this.t += dt; if (this.msgT > 0) this.msgT -= dt; Shake.update(dt); Particles.update(dt); Floats.update(dt);
        if (this.phase === 'intro') { this.introT += dt; if (this.introT > 2 || JP['Enter'] || JP['KeyZ']) this.phase = 'play'; return; }
        if (this.phase === 'results') { if (JP['Enter'] || JP['KeyZ']) { Stats.addXP(this.score * 6, 'stamina'); sfxWin(); go(TrainingSelectState); } return; }
        if (Keys['ArrowUp']) this.py2 = Math.max(H * 0.22, this.py2 - 100 * dt);
        if (Keys['ArrowDown']) this.py2 = Math.min(H * 0.78, this.py2 + 100 * dt);
        this.prevH = this.holding; this.holding = Keys['KeyZ'] || Keys['Space'];
        if (this.holding) this.holdT += dt; else this.holdT = 0;
        this.ballT += dt;
        if (this.ballT >= this.nextBall) { this.ballT = 0; this.nextBall = 1.1 + Math.random() * 0.6; this.balls.push({ x: W - 40, y: H * 0.25 + Math.random() * H * 0.5, vx: -(180 + this.score * 3), done: false, missed: false }); tone(600, 'square', 0.04, 0.1); }
        const tapped = !this.holding && this.prevH && this.holdT < 0.22; // More forgiving tap
        for (const b of this.balls) {
          if (!b.done && !b.missed) b.x += b.vx * dt;
          if (b.x < -10) { b.missed = true; b.done = true; this.lives--; this.msg = 'MISSED!'; this.msgT = 0.8; Shake.add(3); sfxLose(); if (this.lives <= 0) { this.phase = 'results'; sfxFistPump(); } continue; }
          const dx = Math.abs(b.x - W * 0.2), dy = Math.abs(b.y - this.py2);
          if (!b.done && dx < 38 && dy < 38) {
            if (this.holding && this.holdT > 0.18) { b.done = true; this.lives--; this.msg = 'TOO LONG!'; this.msgT = 0.8; Shake.add(3); sfxLose(); Particles.emit(b.x, b.y, { count: 8, color: ['#f04040'], speed: 40, life: 0.3 }); if (this.lives <= 0) this.phase = 'results'; }
            else if (tapped) { b.done = true; this.score++; this.msg = 'COMPACT!'; this.msgT = 0.8; sfxHit(); Shake.add(2); Particles.emit(b.x, b.y, { count: 14, color: [C.orange, C.gold, '#fff'], speed: 65, life: 0.5, upward: 1, glow: true }); Floats.add('BLOCK!', b.x, b.y - 25, C.orange, 10); }
          }
        }
        this.balls = this.balls.filter(b => b.x > -50); if (JP['Escape']) go(TrainingSelectState);
      },
      draw() {
        Shake.apply(); mgBg('#1a100a', '#080510');
        px(0, H * 0.18, W, ~~(H * 0.64), '#2a5a8a'); px(0, H * 0.18, W, 2, '#ffffff22'); px(0, H * 0.82, W, 2, '#ffffff22');
        px(W / 2 - 2, H * 0.18, 4, ~~(H * 0.64), '#ffffffcc'); for (let i = 0; i < 12; i++)px(W / 2 - 2, H * 0.18 + i * 14, 4, 1, '#00000044');
        [[80, H * 0.35, 60, 25], [80, H * 0.6, 60, 25]].forEach(([tx, ty, tw, th]) => { px(tx, ty, tw, th, '#ff404022'); px(tx, ty, tw, 1, '#ff404066'); txt('AIM', tx + tw / 2, ty + 16, C.red, 6, 'center'); });
        px(W - 55, H * 0.28, 24, 28, '#4080c0'); px(W - 50, H * 0.24, 14, 8, '#80c0ff'); txt('130mph', W - 43, H * 0.3, C.dim, 5, 'center');
        for (const b of this.balls) { if (b.done) continue; for (let i = 1; i <= 4; i++) { ctx.fillStyle = `rgba(200,255,64,${0.12 - i * 0.025})`; ctx.fillRect(b.x + 6 + i * 8, b.y - 2, 7, 4); } ctx.save(); ctx.shadowColor = '#c8ff40'; ctx.shadowBlur = 6; px(b.x - 5, b.y - 5, 10, 10, '#c8ff40'); px(b.x - 4, b.y - 4, 3, 3, '#fff'); ctx.restore(); }
        // Action-matched: ready stance, volley on tap, recover on miss
        let mg2Frame = 'ready';
        if (this.holding && this.holdT > 0.15) mg2Frame = 'recover'; // Held too long = stumble
        else if (this.holding) mg2Frame = 'volley'; // Quick block
        else if (this.msgT > 0 && this.msg === 'COMPACT!') mg2Frame = 'forehand'; // Just hit
        else if (Keys['ArrowUp'] || Keys['ArrowDown']) mg2Frame = this.t % 0.24 < 0.12 ? 'run1' : 'run2';
        drawSpr(mg2Frame, W * 0.2 - 14, this.py2 - 20, 28, 38);
        if (this.holding && this.holdT > 0.15) { px(W * 0.2 - 30, this.py2 - 28, 60, 14, 'rgba(224,40,40,0.75)'); txt('LONG!', W * 0.2, this.py2 - 19, C.red, 7, 'center'); }
        if (this.msgT > 0) { ctx.globalAlpha = Math.min(1, this.msgT * 2); txt(this.msg, W / 2, H * 0.87, C.gold, 9, 'center'); ctx.globalAlpha = 1; }
        txt('TAP Z  ·  HOLD = fault', W / 2, H - 7, C.dim, 6, 'center');
        for (let i = 0; i < 5; i++)px(W - 66 + i * 11, 22, 9, 8, i < this.lives ? C.red : '#333');
        Particles.draw(); Floats.draw();
        mgHUD('BORROW THE PACE', C.orange, `BLOCKS:${this.score}`);
        if (this.phase === 'intro') mgIntro('BORROW THE PACE', C.orange, '130mph serves incoming!', 'QUICK TAP [Z] to compact-block', 'HOLD [Z] too long = fault!', 'Move with UP / DOWN arrows', '', 'PRESS Z TO START');
        if (this.phase === 'results') mgResults(this.t, 'Blocks', C.orange, this.score, this.score * 6, 'stamina');
        Shake.restore();
      }
    };

    // ═══ MG3: TOPSPIN SMASH ════════════════════════════════
    const Minigame_TopspinSmash = {
      t: 0, phase: 'intro', introT: 0, bar: 0, barDir: 1, barSpeed: 1.6, swinging: false, swingT: 0, score: 0, lives: 5, barrels: [], msg: '', msgT: 0,
      enter() { Object.assign(this, { t: 0, phase: 'intro', introT: 0, bar: 0, barDir: 1, barSpeed: 1.6, swinging: false, swingT: 0, score: 0, lives: 5, msg: '', msgT: 0 }); this.spawnBarrels(); Particles.pool = []; Floats.pool = []; },
      spawnBarrels() { this.barrels = []; for (let i = 0; i < 8; i++)this.barrels.push({ x: 55 + Math.random() * (W - 110), y: H * 0.54 + Math.random() * 60, alive: true }); },
      update(dt) {
        this.t += dt; if (this.msgT > 0) this.msgT -= dt; Shake.update(dt); Particles.update(dt); Floats.update(dt);
        if (this.phase === 'intro') { this.introT += dt; if (this.introT > 2 || JP['Enter'] || JP['KeyZ']) this.phase = 'play'; return; }
        if (this.phase === 'results') { if (JP['Enter'] || JP['KeyZ']) { Stats.addXP(this.score * 8, 'power'); sfxWin(); go(TrainingSelectState); } return; }
        this.barSpeed = 1.1 + this.score * 0.08; this.bar += this.barDir * this.barSpeed * dt;
        if (this.bar > 1) { this.bar = 1; this.barDir = -1; } if (this.bar < 0) { this.bar = 0; this.barDir = 1; }
        if ((JP['KeyZ'] || JP['Space']) && !this.swinging) {
          this.swinging = true; this.swingT = 0;
          const p = this.bar >= 0.6 && this.bar <= 0.76, g = this.bar >= 0.5 && this.bar <= 0.86;
          if (p) { this.score++; this.msg = 'PERFECT TOPSPIN!'; this.msgT = 1; sfxTopspin(); Shake.add(4); this.hitBarrel(true); Particles.emit(W / 2, H * 0.58, { count: 18, color: ['#c8ff40', '#80ff00', '#fff'], speed: 80, life: 0.5, upward: 2, glow: true }); Floats.add('SMASH!', W / 2, H * 0.47, C.gold, 13); }
          else if (g) { this.score++; this.msg = 'GOOD SPIN!'; this.msgT = 0.8; sfxHit(); Shake.add(2); this.hitBarrel(false); Particles.emit(W / 2, H * 0.58, { count: 10, color: [C.green, '#fff'], speed: 60, life: 0.4, upward: 1 }); }
          else { this.lives--; this.msg = 'WRONG TIMING!'; this.msgT = 0.8; sfxLose(); Shake.add(3); if (this.lives <= 0) { this.phase = 'results'; sfxFistPump(); } }
        }
        if (this.swinging) { this.swingT += dt; if (this.swingT > 0.5) this.swinging = false; }
        if (this.barrels.every(b => !b.alive)) this.spawnBarrels(); if (JP['Escape']) go(TrainingSelectState);
      },
      hitBarrel(p) { const a = this.barrels.filter(b => b.alive); if (!a.length) return; const b = a[~~(Math.random() * a.length)]; b.alive = false; Particles.emit(b.x, b.y, { count: 12, color: ['#8b4513', '#6b3410', C.gold], speed: 55, life: 0.5, spread: Math.PI }); Floats.add(p ? 'SMASH!' : 'HIT!', b.x, b.y - 20, p ? C.gold : C.white, p ? 11 : 8); },
      draw() {
        Shake.apply(); mgBg('#1a0a28', '#080518');
        px(0, H * 0.48, W, ~~(H * 0.52), '#2a4a8a'); px(0, H * 0.48, W, 2, '#ffffff33');
        for (const b of this.barrels) { if (!b.alive) continue; px(b.x - 11, b.y - 15, 22, 22, '#8b4513'); px(b.x - 11, b.y - 12, 22, 3, '#a0522d'); px(b.x - 11, b.y - 6, 22, 3, '#a0522d'); px(b.x - 13, b.y - 15, 2, 22, '#6b3410'); px(b.x + 11, b.y - 15, 2, 22, '#6b3410'); }
        // Action-matched: ready/wind-up/forehand/fist follow-through/celebrate on perfect
        let mg3Frame = 'ready';
        if (this.swinging) {
          if (this.swingT < 0.1) mg3Frame = 'backhand'; // Wind-up
          else if (this.swingT < 0.25) mg3Frame = 'forehand'; // Swing
          else if (this.msg === 'PERFECT TOPSPIN!') mg3Frame = 'fist'; // Follow-through
          else mg3Frame = 'recover'; // Miss recovery
        } else if (this.msg === 'PERFECT TOPSPIN!' && this.msgT > 0.4) mg3Frame = 'celebrate';
        drawSpr(mg3Frame, W / 2 - 14, H * 0.48 - 36, 28, 40);
        const bX = 55, bY = H - 72, bW = W - 110, bH = 22;
        px(bX - 2, bY - 2, bW + 4, bH + 4, '#333'); px(bX, bY, bW, bH, '#0d1020');
        const lo = ~~(0.6 * bW), hi = ~~(0.76 * bW);
        px(bX + ~~(0.5 * bW), bY, ~~(0.1 * bW), bH, '#40ff3018'); px(bX + lo, bY, hi - lo, bH, '#40ff3060');
        txt('LOW', bX + 4, bY + 14, C.dim, 6); txt('TOPSPIN ZONE', bX + lo + (hi - lo) / 2, bY + 14, C.green, 6, 'center'); txt('HIGH', bX + bW - 28, bY + 14, C.dim, 6);
        const cx2 = bX + ~~(this.bar * bW); px(cx2 - 2, bY - 5, 4, bH + 10, '#fff'); txt('▲', cx2, bY - 6, C.white, 7, 'center');
        txt('[Z] when cursor hits GREEN ZONE', W / 2, H - 20, C.accent, 6, 'center');
        if (this.msgT > 0) { ctx.globalAlpha = Math.min(1, this.msgT * 2); txt(this.msg, W / 2, H * 0.36, C.gold, 11, 'center'); ctx.globalAlpha = 1; }
        for (let i = 0; i < 5; i++)px(W - 66 + i * 11, 22, 9, 8, i < this.lives ? C.red : '#333');
        Particles.draw(); Floats.draw();
        mgHUD('TOPSPIN SMASH', C.red, `SMASHES:${this.score}`, `${this.barSpeed.toFixed(1)}x`);
        if (this.phase === 'intro') mgIntro('TOPSPIN SMASH', C.red, 'The timing bar swings LOW to HIGH.', 'Press [Z] when cursor hits', 'the GREEN zone for topspin!', 'Smash the barrels to score!', '', 'PRESS Z TO START');
        if (this.phase === 'results') mgResults(this.t, 'Smashes', C.red, this.score, this.score * 8, 'power');
        Shake.restore();
      }
    };

    // ═══ MG4: SERVICE TOSS ════════════════════════════════
    const Minigame_ServiceToss = {
      t: 0, phase: 'intro', introT: 0, nPos: 0.5, nVel: 0.2, tossing: false, tossT: 0, score: 0, lives: 5, aces: 0, msg: '', msgT: 0,
      enter() { Object.assign(this, { t: 0, phase: 'intro', introT: 0, nPos: 0.5, nVel: 0.2, tossing: false, tossT: 0, score: 0, lives: 5, aces: 0, msg: '', msgT: 0 }); Particles.pool = []; Floats.pool = []; },
      update(dt) {
        this.t += dt; if (this.msgT > 0) this.msgT -= dt; Shake.update(dt); Particles.update(dt); Floats.update(dt);
        if (this.phase === 'intro') { this.introT += dt; if (this.introT > 2 || JP['Enter'] || JP['KeyZ']) this.phase = 'play'; return; }
        if (this.phase === 'results') { if (JP['Enter'] || JP['KeyZ']) { Stats.addXP(this.score * 6, 'serve'); sfxWin(); go(TrainingSelectState); } return; }
        const w = 0.9 + Math.min(2.5, this.score * 0.12); this.nVel += (Math.random() - 0.5) * w * dt * 5; this.nVel *= 0.92;
        if (Keys['ArrowLeft']) this.nVel -= 2 * dt; if (Keys['ArrowRight']) this.nVel += 2 * dt;
        this.nPos += this.nVel * dt; this.nPos = clamp(this.nPos, 0, 1); if (this.nPos <= 0 || this.nPos >= 1) this.nVel *= -0.6;
        if (this.tossing) {
          this.tossT += dt;
          if (this.tossT >= 1.1) {
            this.tossing = false; this.tossT = 0; const off = Math.abs(this.nPos - 0.5);
            if (off < 0.07) { this.aces++; this.score++; this.msg = 'ACE!'; this.msgT = 1; sfxFistPump(); Shake.add(5); Particles.emit(W * 0.2, H * 0.35, { count: 24, color: [C.gold, '#fff', '#c8ff40', C.orange], speed: 85, life: 0.8, upward: 2, glow: true }); Floats.add('ACE!', W / 2, H * 0.4, C.gold, 16); }
            else if (off < 0.15) { this.score++; this.msg = 'GREAT SERVE!'; this.msgT = 0.8; sfxHit(); Shake.add(2); Particles.emit(W * 0.2, H * 0.35, { count: 12, color: [C.green, '#fff'], speed: 55, life: 0.5, upward: 1 }); Floats.add('IN!', W / 2, H * 0.45, C.green, 12); }
            else { this.lives--; this.msg = 'FAULT!'; this.msgT = 0.8; sfxLose(); Shake.add(4); Particles.emit(W / 2, H * 0.45, { count: 10, color: [C.red, '#ff8080'], speed: 40, life: 0.4 }); if (this.lives <= 0) { this.phase = 'results'; sfxFistPump(); } }
          }
        } else if (JP['KeyZ'] || JP['Space']) { this.tossing = true; this.tossT = 0; tone(440, 'sine', 0.08, 0.1); }
        if (JP['Escape']) go(TrainingSelectState);
      },
      draw() {
        Shake.apply(); mgBg('#0a1e14', '#060e0a');
        px(0, H * 0.58, W, ~~(H * 0.42), '#2a6a4a'); px(0, H * 0.58, W, 2, '#ffffff44');
        ctx.strokeStyle = '#ffffff33'; ctx.lineWidth = 1; ctx.strokeRect(W * 0.5, H * 0.58, W * 0.35, H * 0.32); ctx.strokeRect(W * 0.5, H * 0.58, W * 0.35, H * 0.16);
        txt('SERVICE BOX', W * 0.675, H * 0.62, C.dim, 6, 'center');
        // Action-matched: full serve sequence (stand → serveUp → toss → serveHit → celebrate on ACE)
        let mg4Frame = 'stand';
        if (this.tossing) {
          if (this.tossT < 0.3) mg4Frame = 'serveUp'; // Toss preparation
          else if (this.tossT < 0.6) mg4Frame = 'toss'; // Ball at peak
          else if (this.tossT < 0.9) mg4Frame = 'serveHit'; // Striking
          else mg4Frame = 'serve2'; // Follow-through
        } else if (this.msg === 'ACE!' && this.msgT > 0.3) mg4Frame = 'celebrate';
        else if (this.msg === 'FAULT!' && this.msgT > 0) mg4Frame = 'recover';
        drawSpr(mg4Frame, W * 0.18 - 14, H * 0.52 - 36, 28, 40);
        if (this.tossing) { const bx = W * 0.18 + 6, h2 = Math.sin(this.tossT / 1.1 * Math.PI) * 75; for (let i = 3; i >= 0; i--) { ctx.globalAlpha = (4 - i) * 0.06; ctx.fillStyle = '#c8ff40'; ctx.fillRect(bx - 3, H * 0.52 - 36 - h2 * (1 - i * 0.25) - 3, 6, 6); } ctx.globalAlpha = 1; ctx.save(); ctx.shadowColor = '#c8ff40'; ctx.shadowBlur = 12; px(bx - 5, H * 0.52 - 36 - h2 - 5, 10, 10, '#c8ff40'); px(bx - 4, H * 0.52 - 36 - h2 - 4, 3, 3, '#fff'); ctx.restore(); }
        const bX = 55, bY = H - 68, bW = W - 110, bH = 22;
        px(bX - 2, bY - 2, bW + 4, bH + 4, '#333'); px(bX, bY, bW, bH, '#0d1020');
        const ctr = bX + ~~(bW / 2); px(ctr - 42, bY, 84, bH, '#ffff4015'); px(ctr - 22, bY, 44, bH, '#40ff3040'); txt('PERFECT', ctr, bY + 14, C.green, 6, 'center');
        const nx = bX + ~~(this.nPos * bW); px(nx - 2, bY - 6, 4, bH + 10, C.white); txt('▼', nx, bY - 7, C.white, 7, 'center');
        txt('ARROWS:balance  Z:TOSS', W / 2, H - 18, C.accent, 6, 'center');
        if (this.msgT > 0) { ctx.globalAlpha = Math.min(1, this.msgT * 2); txt(this.msg, W / 2, H * 0.35, C.gold, 12, 'center'); ctx.globalAlpha = 1; }
        for (let i = 0; i < 5; i++)px(W - 66 + i * 11, 22, 9, 8, i < this.lives ? C.red : '#333');
        Particles.draw(); Floats.draw();
        mgHUD('SERVICE TOSS', C.gold, `SERVES:${this.score}`, `ACES:${this.aces}`);
        if (this.phase === 'intro') mgIntro('SERVICE TOSS TOWER', C.gold, 'Balance the swaying needle', 'using LEFT / RIGHT ARROWS.', 'When it is centred, press [Z]', 'Centred = ACE serve!', '', 'PRESS Z TO START');
        if (this.phase === 'results') mgResults(this.t, 'Serves', C.gold, this.score, this.score * 6, 'serve', `Aces: ${this.aces}`);
        Shake.restore();
      }
    };

    // ═══ MG5: FIGHTING SPIRIT ══════════════════════════════
    const Minigame_FightingSpirit = {
      t: 0, phase: 'play', circleR: 30, beatT: 0, beatDur: 1, playerR: 30, stamina: 30, pumps: 0, msg: '', msgT: 0, fistFX: 0,
      enter() { Object.assign(this, { t: 0, phase: 'play', circleR: 30, beatT: 0, beatDur: 1, playerR: 30, stamina: 30, pumps: 0, msg: '', msgT: 0, fistFX: 0 }); Particles.pool = []; Floats.pool = []; },
      update(dt) {
        this.t += dt; if (this.msgT > 0) this.msgT -= dt; if (this.fistFX > 0) this.fistFX -= dt;
        Shake.update(dt); Particles.update(dt); Floats.update(dt);
        if (this.phase === 'results') { if (JP['Enter'] || JP['KeyZ']) { Stats.addXP(this.pumps * 5, 'stamina'); sfxWin(); go(TrainingSelectState); } return; }
        this.beatDur = Math.max(0.55, 1 - this.pumps * 0.04); this.beatT += dt;
        const half = this.beatDur / 2; this.circleR = this.beatT < half ? 24 + (this.beatT / half) * 48 : 72 - ((this.beatT - half) / half) * 48;
        if (this.beatT >= this.beatDur) { this.beatT = 0; tone(180, 'sine', 0.12, 0.05); }
        if (Keys['KeyZ'] || Keys['Space']) this.playerR = Math.min(72, this.playerR + 130 * dt); else this.playerR = Math.max(24, this.playerR - 90 * dt);
        const diff = Math.abs(this.playerR - this.circleR);
        if (diff < 9) this.stamina = Math.min(100, this.stamina + 14 * dt); else this.stamina = Math.max(0, this.stamina - 1.5 * dt);
        if (this.stamina >= 100) {
          this.pumps++; this.stamina = 35; this.fistFX = 1.8; this.msg = 'FIST PUMP! STAMINA!'; this.msgT = 1.8; sfxFistPump(); Shake.add(6);
          Particles.emit(W / 2, H * 0.45, { count: 28, color: [C.gold, C.orange, '#fff', C.cyan], speed: 90, life: 0.9, upward: 2, glow: true, spread: Math.PI * 2 });
          Floats.add('FIST PUMP!', W / 2, H * 0.3, C.gold, 14);
          if (this.pumps >= 5) setTimeout(() => { this.phase = 'results'; }, 1200);
        }
        if (JP['Escape']) go(TrainingSelectState);
      },
      draw() {
        Shake.apply();
        const pulse = Math.sin(this.t * 2) * 0.03;
        const bg = ctx.createRadialGradient(W / 2, H * 0.45, 30, W / 2, H * 0.45, 200); bg.addColorStop(0, `rgba(28,8,48,${0.8 + pulse})`); bg.addColorStop(1, '#060612'); ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);
        ctx.save(); ctx.globalAlpha = 0.35; ctx.strokeStyle = 'rgba(80,80,255,0.8)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(W / 2, H * 0.42, this.circleR, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = 'rgba(60,60,200,0.06)'; ctx.fill(); ctx.restore();
        txt(this.beatT < this.beatDur / 2 ? 'INHALE' : 'exhale', W / 2, H * 0.42 + 5, this.beatT < this.beatDur / 2 ? '#9090ff' : '#5050aa', 8, 'center');
        txt('MATCH THE CIRCLE', W / 2, H * 0.42 - this.circleR - 16, C.dim, 7, 'center');
        const diff = Math.abs(this.playerR - this.circleR), mc = diff < 9 ? C.green : diff < 18 ? C.gold : C.red;
        ctx.save(); ctx.shadowColor = mc; ctx.shadowBlur = 20; ctx.strokeStyle = mc; ctx.lineWidth = 4; ctx.globalAlpha = 0.85; ctx.beginPath(); ctx.arc(W / 2, H * 0.42, this.playerR, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
        txt('HOLD Z=EXPAND  RELEASE=SHRINK', W / 2, H * 0.42 + 95, C.dim, 6, 'center');
        // Action-matched: breathe during sync, fist on pump, celebrate on completion
        if (this.fistFX > 0) {
          ctx.save(); const sc = 1 + this.fistFX * 0.15;
          ctx.translate(W / 2, H * 0.58); ctx.scale(sc, sc);
          drawSpr(this.fistFX > 1 ? 'celebrate' : 'fist', -20, -30, 40, 50);
          ctx.restore();
          ctx.globalAlpha = Math.min(1, this.fistFX);
          txt('PUMPED!', W / 2, H * 0.65, C.gold, 10, 'center');
          ctx.globalAlpha = 1;
        } else {
          // Breathing animation — switch between breathe/ready based on sync quality
          const diff = Math.abs(this.playerR - this.circleR);
          const mg5Frame = diff < 9 ? 'breathe' : (Keys['KeyZ'] || Keys['Space'] ? 'ready' : 'idle');
          drawSpr(mg5Frame, W / 2 - 12, H * 0.6 - 30, 24, 34);
        }
        const sbX = 60, sbY = H * 0.74, sbW = W - 120, sbH = 18; px(sbX, sbY, sbW, sbH, '#1a1a2a'); const stW = ~~((this.stamina / 100) * sbW); px(sbX, sbY, stW, sbH, this.stamina > 60 ? C.green : this.stamina > 30 ? C.gold : C.red); px(sbX, sbY, sbW, 1, '#ffffff22'); txt('FIGHTING SPIRIT', W / 2, sbY + 13, C.purple, 7, 'center');
        for (let i = 0; i < 5; i++) { px(W / 2 - 60 + i * 26, H * 0.8, 20, 20, i < this.pumps ? C.orange : '#222'); if (i < this.pumps) px(W / 2 - 57 + i * 26, H * 0.8 + 3, 14, 14, C.gold); }
        txt('5 PUMPS TO WIN', W / 2, H * 0.87, C.dim, 6, 'center');
        if (this.msgT > 0) { ctx.globalAlpha = Math.min(1, this.msgT); txt(this.msg, W / 2, H * 0.89, C.gold, 9, 'center'); ctx.globalAlpha = 1; }
        Particles.draw(); Floats.draw();
        px(0, 0, W, 20, 'rgba(6,10,20,0.95)'); px(0, 19, W, 1, C.purple + '66'); txt('FIGHTING SPIRIT', 5, 13, C.purple, 7); txt(`PUMPS:${this.pumps}/5`, 290, 13, C.gold, 7); txt(`BPM:${~~(60 / this.beatDur)}`, 410, 13, C.cyan, 7);
        if (this.phase === 'results') { ctx.fillStyle = 'rgba(6,10,20,0.92)'; ctx.fillRect(60, 60, W - 120, 250); px(60, 60, W - 120, 2, C.purple); txt('SPIRIT RESTORED!', W / 2, 95, C.gold, 12, 'center'); drawSpr('fist', W / 2 - 22, 108, 44, 56); txt(`Fist Pumps: ${this.pumps}`, W / 2, 180, C.white, 9, 'center'); txt(`+${this.pumps * 5} STAMINA XP`, W / 2, 208, C.accent, 9, 'center'); if (~~(this.t * 2) % 2 === 0) txt('PRESS Z TO CONTINUE', W / 2, 255, C.gold, 7, 'center'); }
        Shake.restore();
      }
    };

    // ═══ PRO SHOP ═══════════════════════════════════════════
    const ShopState = {
      t: 0, sel: 0,
      items: [
        { name: 'POWER RACKET', stat: 'power', color: C.red, desc: 'Harder groundstrokes', icon: 'forehand', cost: 25 },
        { name: 'SPEED SHOES', stat: 'agility', color: C.cyan, desc: 'Faster court coverage', icon: 'run1', cost: 25 },
        { name: 'STAMINA DRINK', stat: 'stamina', color: C.green, desc: 'Longer rallies', icon: 'stand', cost: 20 },
        { name: 'TOUCH GRIP', stat: 'touch', color: C.purple, desc: 'Better drop shots & volleys', icon: 'slice', cost: 30 },
        { name: 'SERVE STRING', stat: 'serve', color: C.gold, desc: 'Faster, more accurate serves', icon: 'serveHit', cost: 30 }
      ],
      msg: '', msgT: 0,
      enter() { this.t = 0; this.sel = 0; this.msg = ''; this.msgT = 0; },
      update(dt) {
        this.t += dt; if (this.msgT > 0) this.msgT -= dt;
        if (JP['ArrowUp']) { this.sel = (this.sel - 1 + 5) % 5; sfxMenu(); }
        if (JP['ArrowDown']) { this.sel = (this.sel + 1) % 5; sfxMenu(); }
        if (JP['Enter'] || JP['KeyZ']) {
          const item = this.items[this.sel];
          const lvl = Math.floor(Stats[item.stat] / 10);
          const price = item.cost + lvl * 15;
          if (Stats.coins >= price && Stats[item.stat] < 99) {
            Stats.coins -= price;
            Stats[item.stat] = Math.min(99, Stats[item.stat] + 5);
            sfxWin(); Shake.add(3);
            this.msg = `${item.stat.toUpperCase()} +5!`; this.msgT = 1.5;
            Particles.emit(W / 2, H * 0.5, { count: 16, color: [item.color, '#fff', C.gold], speed: 60, life: 0.6, upward: 2, glow: true });
          } else if (Stats[item.stat] >= 99) {
            this.msg = 'MAXED OUT!'; this.msgT = 1; sfxLose();
          } else {
            this.msg = 'NOT ENOUGH COINS!'; this.msgT = 1; sfxLose();
          }
        }
        Shake.update(dt); Particles.update(dt); Floats.update(dt);
        if (JP['Escape']) go(HubState);
      },
      draw() {
        Shake.apply();
        const bg = ctx.createLinearGradient(0, 0, 0, H);
        bg.addColorStop(0, '#1a0a2e'); bg.addColorStop(1, '#0a0618');
        ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);
        // Header
        px(0, 0, W, 34, 'rgba(0,0,0,0.7)'); px(0, 33, W, 1, C.purple + '88');
        txt('PRO SHOP', W / 2, 14, C.purple, 12, 'center');
        txt(`COINS: ${Stats.coins}`, W / 2, 28, C.gold, 7, 'center');
        // Items
        this.items.forEach((item, i) => {
          const y = 42 + i * 58, sel = i === this.sel;
          const lvl = Math.floor(Stats[item.stat] / 10);
          const price = item.cost + lvl * 15;
          const maxed = Stats[item.stat] >= 99;
          // Card
          ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10;
          px(20, y, W - 40, 52, sel ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.5)');
          ctx.shadowBlur = 0;
          px(20, y, 4, 52, item.color); if (sel) {
            px(20, y, W - 40, 1, item.color);
            px(20, y + 51, W - 40, 1, item.color + '66');
            ctx.fillStyle = item.color + '15'; ctx.fillRect(20, y, W - 40, 52);
          }
          // Icon
          drawSpr(item.icon, 30, y + 6, 24, 34);
          // Info
          txt(item.name, 62, y + 16, sel ? C.accent : C.white, 8);
          txt(item.desc, 62, y + 32, C.dim, 6);
          // Stat bar
          bar(W - 110, y + 10, 70, 8, Stats[item.stat], 99, item.color, '#1a1a2a');
          txt(`${Stats[item.stat]}/99`, W - 75, y + 30, item.color, 6, 'center');
          // Price
          if (maxed) {
            txt('MAX', W - 42, y + 42, C.gold, 6, 'center');
          } else {
            const canAfford = Stats.coins >= price;
            txt(`${price}¢`, W - 42, y + 42, canAfford ? C.gold : C.red, 7, 'center');
          }
          if (sel) txt('◀', W - 18, y + 26, C.gold, 8);
        });
        // Message
        if (this.msgT > 0) {
          ctx.globalAlpha = Math.min(1, this.msgT * 2);
          txt(this.msg, W / 2, H - 40, C.gold, 10, 'center');
          ctx.globalAlpha = 1;
        }
        Particles.draw(); Floats.draw();
        txt('[Z] BUY  |  ESC: BACK', W / 2, H - 10, C.dim, 6, 'center');
        Shake.restore();
      }
    };

    // ═══ GAME LOOP ═══════════════════════════════════════════
    let lastT = 0;
    function loop(ts) {
      const dt = Math.min((ts - lastT) / 1000, 0.05); lastT = ts;
      ctx.fillStyle = '#060a10'; ctx.fillRect(0, 0, W, H);

      if (freezeT > 0) {
        freezeT -= dt;
        if (STATE) STATE.draw();
      } else {
        if (STATE) { STATE.update(dt); STATE.draw(); Transition.draw(); }
      }

      Transition.update(dt);
      clearInput(); requestAnimationFrame(loop);
    }
    go(HomeState);
    requestAnimationFrame(loop);
  </script>
</body>

</html>