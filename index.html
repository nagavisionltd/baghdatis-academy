<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Baghdatis Academy: Pixel Pathway</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #060a0f; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; overflow: hidden; touch-action: none; user-select: none; }
    #wrap { position: relative; transform-origin: center center; }
    canvas { display: block; image-rendering: pixelated; background: #000; }
    #hint { color: #2a3550; font-family: 'Courier New', monospace; font-size: 10px; text-align: center; margin-top: 5px; letter-spacing: 2px; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="game" width="512" height="384"></canvas></div>
  <div id="hint">ARROWS · Z=ACTION · X=SLICE · ESC=BACK | v2026.5</div>
  <script>
    'use strict';
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 512, H = 384;

    function resizeGame() {
      const vw = window.innerWidth, vh = window.innerHeight;
      const scale = Math.min((vw - 20) / W, (vh - 44) / H);
      document.getElementById('wrap').style.transform = `scale(${scale})`;
    }
    window.addEventListener('resize', resizeGame); resizeGame();

    // Assets
    const spr = new Image(); spr.src = 'marcos_sheet.png?v=2026';
    const oppSpr = new Image(); oppSpr.src = 'opponent_sheet_new.png?v=2026';
    const titleBg = new Image(); titleBg.src = 'title_bg_hd.png?v=2026';
    const introBg = new Image(); introBg.src = 'intro_bg.png?v=2026';
    const thumbs = { split: new Image(), pace: new Image(), smash: new Image(), toss: new Image(), spirit: new Image() };
    thumbs.split.src = 'thumb_split.png?v=2026'; thumbs.pace.src = 'thumb_pace.png?v=2026';
    thumbs.smash.src = 'thumb_smash.png?v=2026'; thumbs.toss.src = 'thumb_toss.png?v=2026'; thumbs.spirit.src = 'thumb_spirit.png?v=2026';
    
    let sprLoaded = false, oppLoaded = false, titleBgLoaded = false;
    spr.onload = () => sprLoaded = true; oppSpr.onload = () => oppLoaded = true; titleBg.onload = () => titleBgLoaded = true;

    const FRAMES = {
      idle: [0, 0], run1: [1, 0], run2: [2, 0], forehand: [3, 0], backhand: [4, 0],
      serveUp: [0, 1], serveHit: [1, 1], fist: [2, 1], dive: [3, 1], stand: [4, 1],
      slice: [0, 2], volley: [1, 2], lob: [2, 2], splitStep: [3, 2], breathe: [4, 2],
      serve2: [0, 3], toss: [1, 3], celebrate: [2, 3], ready: [3, 3], recover: [4, 3]
    };

    function drawSpr(name, x, y, w, h, flipX = false, alpha = 1, sheet = null) {
      const img = sheet || spr, loaded = sheet ? oppLoaded : sprLoaded;
      ctx.save(); ctx.globalAlpha = alpha;
      if (!loaded) { ctx.fillStyle = sheet ? '#e03030' : '#f06020'; ctx.fillRect(x, y + h * 0.3, w, h * 0.7); ctx.restore(); return; }
      const f = FRAMES[name] || FRAMES.stand;
      const sx = f[0] * 128, sy = f[1] * 160;
      if (flipX) { ctx.translate(x + w, y); ctx.scale(-1, 1); ctx.drawImage(img, sx, sy, 128, 160, 0, 0, w, h); }
      else ctx.drawImage(img, sx, sy, 128, 160, x, y, w, h);
      ctx.restore();
    }

    // Input
    const Keys = {}, JP = {}, JR = {};
    window.onkeydown = e => { if (!Keys[e.code]) JP[e.code] = true; Keys[e.code] = true; if (ga() && ga().state === 'suspended') ga().resume(); };
    window.onkeyup = e => { Keys[e.code] = false; JR[e.code] = true; };
    function clearInput() { for (const k in JP) delete JP[k]; for (const k in JR) delete JR[k]; }

    // Audio
    let AC = null;
    const ga = () => { if (!AC) try { AC = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { } return AC; };
    function tone(f, type = 'square', dur = 0.1, vol = 0.15, d = 0) {
      const ac = ga(); if (!ac) return;
      const o = ac.createOscillator(), g = ac.createGain();
      o.connect(g); g.connect(ac.destination);
      o.type = type; o.frequency.value = f;
      const t = ac.currentTime + d;
      g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.001, t + dur);
      o.start(t); o.stop(t + dur + 0.05);
    }
    function sfxHit() { tone(400, 'square', 0.06, 0.18); tone(600, 'square', 0.04, 0.1, 0.04); }
    function sfxBounce() { tone(200, 'sine', 0.07, 0.1); }
    function sfxWin() { [523, 659, 784, 1047].forEach((f, i) => tone(f, 'square', 0.14, 0.18, i * 0.1)); }
    function sfxFistPump() { [392, 523, 659, 784, 1047].forEach((f, i) => tone(f, 'square', 0.16, 0.2, i * 0.08)); }
    function sfxLose() { tone(180, 'sawtooth', 0.3, 0.2); }
    function sfxConfirm() { tone(523, 'square', 0.06, 0.12); tone(784, 'square', 0.08, 0.12, 0.06); }
    function sfxMenu() { tone(523, 'square', 0.06, 0.1); }
    function sfxCancel() { tone(330, 'sawtooth', 0.08, 0.1); }

    let bgmPlaying = false, bgmTimeout = null, bgmGen = 0, bgmNodes = [];
    function startBGM() {
      const ac = ga(); if (!ac || bgmPlaying) return; 
      bgmPlaying = true; bgmGen++;
      const myGen = bgmGen;
      const melody = [523, 659, 784, 659, 523, 784, 659, 523, 587, 698, 784, 698, 587, 523, 440, 523];
      const bass = [262, 262, 330, 330, 349, 349, 262, 262];
      const loopDur = melody.length * 0.25;
      function playLoop() {
        if (!bgmPlaying || myGen !== bgmGen) return;
        const now = ac.currentTime;
        melody.forEach((f, i) => {
          const o = ac.createOscillator(), g = ac.createGain();
          o.connect(g); g.connect(ac.destination); o.type = 'square'; o.frequency.value = f;
          g.gain.setValueAtTime(0.04, now + i * 0.25); g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.25 + 0.22);
          o.start(now + i * 0.25); o.stop(now + i * 0.25 + 0.24); bgmNodes.push(o);
        });
        bgmTimeout = setTimeout(playLoop, loopDur * 1000);
      }
      playLoop();
    }
    function stopBGM() { 
      bgmPlaying = false; bgmGen++; 
      if (bgmTimeout) clearTimeout(bgmTimeout); 
      bgmNodes.forEach(n => { try { n.stop(); } catch (e) { } }); bgmNodes = []; 
    }

    // State machine
    let STATE = null, curMap = 0, targetMap = 0, freezeT = 0;
    const Stats = { power: 25, agility: 25, stamina: 25, touch: 25, serve: 25, level: 1, xp: 0, coins: 50, gymChampionsDefeated: 0, addXP(a, s) { this.xp += a; if(s) this[s]=Math.min(99, this[s]+~~(a/10)); while(this.xp>=this.level*100){this.xp-=this.level*100;this.level++;} } };

    const Transition = {
      active: false, t: 0, dur: 0.5, cb: null,
      start(cb) { if(this.active) return; this.active = true; this.t = 0; this.cb = cb; },
      update(dt) { if(!this.active) return; this.t += dt; if(this.t >= this.dur/2 && this.cb){ this.cb(); this.cb = null; } if(this.t >= this.dur) this.active = false; },
      draw() { if(!this.active) return; const a = this.t < 0.25 ? this.t/0.25 : 1-(this.t-0.25)/0.25; ctx.fillStyle = `rgba(6,10,20,${Math.min(1,a)})`; ctx.fillRect(0,0,W,H); }
    };

    function go(s) { if(STATE?.exit) STATE.exit(); stopBGM(); STATE = s; if(STATE?.enter) STATE.enter(); }
    function goTransition(s) { Transition.start(() => go(s)); }

    const HomeState = {
      t: 0, sel: 0,
      enter() { this.t = 0; startBGM(); },
      update(dt) {
        this.t += dt;
        if (JP['ArrowUp']) { this.sel = (this.sel - 1 + 2) % 2; sfxMenu(); }
        if (JP['ArrowDown']) { this.sel = (this.sel + 1) % 2; sfxMenu(); }
        if (JP['Enter'] || JP['KeyZ']) { sfxConfirm(); if(this.sel === 0) goTransition(IntroCutsceneState); else goTransition(TrainingSelectState); }
      },
      draw() {
        ctx.fillStyle = '#060a10'; ctx.fillRect(0,0,W,H);
        ctx.textAlign = 'center';
        txt('BAGHDATIS', W/2, H/2 - 40, '#f0c040', 24);
        txt('ACADEMY', W/2, H/2 - 10, '#f06020', 18);
        txt(this.sel === 0 ? '> NEW GAME <' : '  NEW GAME', W/2, H/2 + 40, this.sel === 0 ? '#fff' : '#444', 10);
        txt(this.sel === 1 ? '> TRAINING <' : '  TRAINING', W/2, H/2 + 65, this.sel === 1 ? '#fff' : '#444', 10);
        txt('v2026.5 FINAL', W/2, H - 20, '#2a3550', 6);
      }
    };

    const IntroCutsceneState = {
      t: 0, transitioning: false,
      enter() { this.t = 0; this.transitioning = false; startBGM(); },
      update(dt) {
        if(Transition.active || this.transitioning) return;
        this.t += dt;
        if(JP['KeyZ'] || JP['Enter'] || this.t > 10) { this.transitioning = true; goTransition(HubState); }
      },
      draw() {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
        ctx.textAlign = 'center';
        txt('In the heart of the city...', W/2, H/2, '#fff', 10);
        txt('A legend is born.', W/2, H/2 + 30, '#f0c040', 8);
        txt('PRESS Z TO START', W/2, H - 40, '#444', 6);
      }
    };

    const LoadingScreenState = {
      t: 0, transitioning: false,
      enter() { this.t = 0; this.transitioning = false; sfxFistPump(); },
      update(dt) {
        if(Transition.active || this.transitioning) return;
        this.t += dt;
        if(this.t > 3) { this.transitioning = true; goTransition(HubState); }
      },
      draw() {
        ctx.fillStyle = '#0a1020'; ctx.fillRect(0,0,W,H);
        txt(curMap === 1 ? 'HEADING TO CITY GYM...' : 'RETURNING TO ACADEMY...', W/2, H/2, '#f0c040', 8, 'center');
        px(W/2-100, H/2+20, Math.min(200, (this.t/3)*200), 4, '#0ff');
      }
    };

    const HubState = {
      px: W/2, py: H*0.6,
      enter() { 
        stopBGM(); 
        if(curMap === 0) { this.px = W/2; this.py = H*0.65; }
        else { this.px = 100; this.py = H*0.7; }
      },
      update(dt) {
        if(Transition.active) return;
        let dx = 0, dy = 0;
        if(Keys['ArrowLeft']) dx = -1; if(Keys['ArrowRight']) dx = 1;
        if(Keys['ArrowUp']) dy = -1; if(Keys['ArrowDown']) dy = 1;
        if(dx||dy){ const l=Math.sqrt(dx*dx+dy*dy); this.px+=dx/l*120*dt; this.py+=dy/l*120*dt; }
        this.px = Math.max(20, Math.min(W-20, this.px)); this.py = Math.max(100, Math.min(H-20, this.py));

        const busX = curMap === 0 ? 210 : 400, busY = curMap === 0 ? 320 : 300;
        if(Math.sqrt((this.px-(busX+40))**2 + (this.py-(busY+16))**2) < 50 && JP['KeyZ']) {
          sfxConfirm();
          const next = curMap === 0 ? 1 : 0;
          Transition.start(() => { curMap = next; go(LoadingScreenState); });
        }
        if(JP['Escape']) goTransition(HomeState);
      },
      draw() {
        ctx.fillStyle = curMap === 0 ? '#4a9a38' : '#222'; ctx.fillRect(0,0,W,H);
        ctx.fillStyle = '#8cf'; ctx.fillRect(0,0,W,100);
        const busX = curMap === 0 ? 210 : 400, busY = curMap === 0 ? 320 : 300;
        px(busX, busY, 80, 32, '#2060c0'); 
        txt(curMap === 0 ? 'TO CITY' : 'TO ACADEMY', busX+40, busY+20, '#fff', 5, 'center');
        px(this.px-10, this.py-20, 20, 30, '#f06020'); // Player
        txt(curMap === 0 ? 'ACADEMY HUB' : 'CITY GYM', W/2, 30, '#fff', 10, 'center');
        txt('WALK TO BUS + Z TO TRAVEL', W/2, H-20, '#aaa', 6, 'center');
      }
    };

    const TrainingSelectState = {
      sel: 0,
      update() { 
        if(JP['ArrowUp']) this.sel=(this.sel-1+2)%2;
        if(JP['ArrowDown']) this.sel=(this.sel+1)%2;
        if(JP['Escape']) goTransition(HubState);
      },
      draw() {
        ctx.fillStyle = '#0a1020'; ctx.fillRect(0,0,W,H);
        txt('TRAINING ZONE', W/2, 40, '#f0c040', 12, 'center');
        txt('COMING SOON', W/2, H/2, '#fff', 8, 'center');
        txt('ESC: BACK', 10, H-10, '#444', 6);
      }
    };

    function txt(t, x, y, c, s, a='center') { ctx.fillStyle=c; ctx.font=s+'px "Press Start 2P"'; ctx.textAlign=a; ctx.fillText(t,x,y); }
    function px(x,y,w,h,c){ ctx.fillStyle=c; ctx.fillRect(x,y,w,h); }
    function clamp(v,min,max){return Math.max(min,Math.min(max,v));}

    let lastT = 0;
    function loop(ts) {
      const dt = Math.min((ts - lastT) / 1000, 0.05); lastT = ts;
      if (STATE) { STATE.update(dt); STATE.draw(); }
      Transition.update(dt); Transition.draw();
      clearInput(); requestAnimationFrame(loop);
    }
    go(HomeState);
    requestAnimationFrame(loop);
  </script>
</body>
</html>